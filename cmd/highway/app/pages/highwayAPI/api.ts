/**
 * common/core.proto
 * Package common defines commonly used types agnostic to the node role on the Sonr network.
 *
 * OpenAPI spec version: v0.14.7
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as localVarRequest from "request";
import * as http from "http";

let defaultBasePath = "https://localhost";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
  "string",
  "boolean",
  "double",
  "integer",
  "long",
  "float",
  "number",
  "any",
];

class ObjectSerializer {
  public static findCorrectType(data: any, expectedType: string) {
    if (data == undefined) {
      return expectedType;
    } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
      return expectedType;
    } else if (expectedType === "Date") {
      return expectedType;
    } else {
      if (enumsMap[expectedType]) {
        return expectedType;
      }

      if (!typeMap[expectedType]) {
        return expectedType; // w/e we don't know the type
      }

      // Check the discriminator
      let discriminatorProperty = typeMap[expectedType].discriminator;
      if (discriminatorProperty == null) {
        return expectedType; // the type does not have a discriminator. use it.
      } else {
        if (data[discriminatorProperty]) {
          return data[discriminatorProperty]; // use the type given in the discriminator
        } else {
          return expectedType; // discriminator was not present (or an empty string)
        }
      }
    }
  }

  public static serialize(data: any, type: string) {
    if (data == undefined) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf("Array<", 0) === 0) {
      // string.startsWith pre es6
      let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      let transformedData: any[] = [];
      for (let index in data) {
        let date = data[index];
        transformedData.push(ObjectSerializer.serialize(date, subType));
      }
      return transformedData;
    } else if (type === "Date") {
      return data.toString();
    } else {
      if (enumsMap[type]) {
        return data;
      }
      if (!typeMap[type]) {
        // in case we dont know the type
        return data;
      }

      // get the map for the correct type.
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      let instance: { [index: string]: any } = {};
      for (let index in attributeTypes) {
        let attributeType = attributeTypes[index];
        instance[attributeType.baseName] = ObjectSerializer.serialize(
          data[attributeType.name],
          attributeType.type
        );
      }
      return instance;
    }
  }

  public static deserialize(data: any, type: string) {
    // polymorphism may change the actual type.
    type = ObjectSerializer.findCorrectType(data, type);
    if (data == undefined) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf("Array<", 0) === 0) {
      // string.startsWith pre es6
      let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      let transformedData: any[] = [];
      for (let index in data) {
        let date = data[index];
        transformedData.push(ObjectSerializer.deserialize(date, subType));
      }
      return transformedData;
    } else if (type === "Date") {
      return new Date(data);
    } else {
      if (enumsMap[type]) {
        // is Enum
        return data;
      }

      if (!typeMap[type]) {
        // dont know the type
        return data;
      }
      let instance = new typeMap[type]();
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      for (let index in attributeTypes) {
        let attributeType = attributeTypes[index];
        instance[attributeType.name] = ObjectSerializer.deserialize(
          data[attributeType.baseName],
          attributeType.type
        );
      }
      return instance;
    }
  }
}

/**
 * BucketType is the type of a bucket.   - BUCKET_TYPE_UNSPECIFIED: BucketTypeUnspecified is the default value.  - BUCKET_TYPE_APP: BucketTypeApp is an App specific bucket. For Assets regarding the service.  - BUCKET_TYPE_USER: BucketTypeUser is a User specific bucket. For any remote user data that is required to be stored in the Network.
 */
export class CommonBucketType {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return CommonBucketType.attributeTypeMap;
  }
}

/**
 * Did represents a string that has been parsed and validated as a DID. The parts are stored in the individual fields.
 */
export class CommonDid {
  /**
   * Method is the method used to create the DID. For the Sonr network it is \"sonr\".
   */
  "method"?: string;
  /**
   * Network is the network the DID is on. For testnet it is \"testnet\". i.e \"did:sonr:testnet:\".
   */
  "network"?: string;
  "id"?: string;
  /**
   * Paths is a list of paths that the DID is valid for. This is used to identify the Service.
   */
  "paths"?: Array<string>;
  /**
   * Query is the query string that was used to create the DID. This is followed by a '?'.
   */
  "query"?: string;
  /**
   * Fragment is the fragment string that was used to create the DID. This is followed by a '#'.
   */
  "fragment"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "method",
      baseName: "method",
      type: "string",
    },
    {
      name: "network",
      baseName: "network",
      type: "string",
    },
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
    {
      name: "paths",
      baseName: "paths",
      type: "Array<string>",
    },
    {
      name: "query",
      baseName: "query",
      type: "string",
    },
    {
      name: "fragment",
      baseName: "fragment",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return CommonDid.attributeTypeMap;
  }
}

/**
 * DidDocument is the document that describes a DID. This document is stored on the blockchain.
 */
export class CommonDidDocument {
  /**
   * Context is the context of the DID document. This is used to identify the Service.
   */
  "context"?: Array<string>;
  /**
   * Id is the DID of the document.
   */
  "id"?: string;
  /**
   * Controller is the DID of the controller of the document. This will be the individual user devices and mailboxes.
   */
  "controller"?: Array<string>;
  /**
   * VerificationMethod is the list of verification methods for the user.
   */
  "verificationMethod"?: Array<CommonVerificationMethod>;
  /**
   * Authentication is the list of authentication methods for the user.
   */
  "authentication"?: Array<string>;
  /**
   * AssertionMethod is the list of assertion methods for the user.
   */
  "assertionMethod"?: Array<string>;
  /**
   * CapabilityInvocation is the list of capability invocation methods for the user.
   */
  "capabilityInvocation"?: Array<string>;
  /**
   * CapabilityDelegation is the list of capability delegation methods for the user.
   */
  "capabilityDelegation"?: Array<string>;
  /**
   * KeyAgreement is the list of key agreement methods for the user.
   */
  "keyAgreement"?: Array<string>;
  /**
   * Service is the list of services or DApps that the user has access to.
   */
  "service"?: Array<CommonService>;
  /**
   * AlsoKnownAs is the list of \".snr\" aliases for the user.
   */
  "alsoKnownAs"?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "context",
      baseName: "context",
      type: "Array<string>",
    },
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
    {
      name: "controller",
      baseName: "controller",
      type: "Array<string>",
    },
    {
      name: "verificationMethod",
      baseName: "verificationMethod",
      type: "Array<CommonVerificationMethod>",
    },
    {
      name: "authentication",
      baseName: "authentication",
      type: "Array<string>",
    },
    {
      name: "assertionMethod",
      baseName: "assertionMethod",
      type: "Array<string>",
    },
    {
      name: "capabilityInvocation",
      baseName: "capabilityInvocation",
      type: "Array<string>",
    },
    {
      name: "capabilityDelegation",
      baseName: "capabilityDelegation",
      type: "Array<string>",
    },
    {
      name: "keyAgreement",
      baseName: "keyAgreement",
      type: "Array<string>",
    },
    {
      name: "service",
      baseName: "service",
      type: "Array<CommonService>",
    },
    {
      name: "alsoKnownAs",
      baseName: "alsoKnownAs",
      type: "Array<string>",
    },
  ];

  static getAttributeTypeMap() {
    return CommonDidDocument.attributeTypeMap;
  }
}

/**
 * Direction is the direction of a stream.   - DIRECTION_UNSPECIFIED: Unspecified is the default value.  - DIRECTION_INCOMING: Incoming is the direction of an incoming stream.  - DIRECTION_OUTGOING: Outgoing is the direction of an outgoing stream.
 */
export class CommonDirection {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return CommonDirection.attributeTypeMap;
  }
}

export class CommonFileItem {
  "mime"?: CommonMIME;
  "name"?: string;
  "path"?: string;
  "size"?: string;
  "thumbnail"?: CommonThumbnail;
  "lastModified"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "mime",
      baseName: "mime",
      type: "CommonMIME",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "path",
      baseName: "path",
      type: "string",
    },
    {
      name: "size",
      baseName: "size",
      type: "string",
    },
    {
      name: "thumbnail",
      baseName: "thumbnail",
      type: "CommonThumbnail",
    },
    {
      name: "lastModified",
      baseName: "lastModified",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return CommonFileItem.attributeTypeMap;
  }
}

export class CommonMIME {
  "type"?: CommonMIMEType;
  "subtype"?: string;
  "value"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "type",
      baseName: "type",
      type: "CommonMIMEType",
    },
    {
      name: "subtype",
      baseName: "subtype",
      type: "string",
    },
    {
      name: "value",
      baseName: "value",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return CommonMIME.attributeTypeMap;
  }
}

/**
 * - TYPE_UNSPECIFIED: Other File Type - If cannot derive from Subtype  - TYPE_AUDIO: Sound, Audio Files  - TYPE_DOCUMENT: Document Files - PDF, Word, Excel, etc.  - TYPE_IMAGE: Image Files  - TYPE_TEXT: Text Based Files  - TYPE_VIDEO: Video Files  - TYPE_URL: URL Links  - TYPE_CRYPTO: Crypto Files
 */
export class CommonMIMEType {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return CommonMIMEType.attributeTypeMap;
  }
}

export class CommonMetadata {
  "timestamp"?: string;
  "nodeId"?: string;
  "signature"?: string;
  "publicKey"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "timestamp",
      baseName: "timestamp",
      type: "string",
    },
    {
      name: "nodeId",
      baseName: "nodeId",
      type: "string",
    },
    {
      name: "signature",
      baseName: "signature",
      type: "string",
    },
    {
      name: "publicKey",
      baseName: "publicKey",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return CommonMetadata.attributeTypeMap;
  }
}

/**
 * ObjectDoc is a document for an Object stored in the graph.
 */
export class CommonObjectDoc {
  /**
   * Did is the identifier of the object.
   */
  "did"?: string;
  /**
   * Service is the service that created the object.
   */
  "service"?: string;
  /**
   * Tags are the tags associated with the object.
   */
  "tags"?: Array<string>;
  /**
   * Fields are the fields associated with the object.
   */
  "fields"?: { [key: string]: CommonObjectField };

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "did",
      baseName: "did",
      type: "string",
    },
    {
      name: "service",
      baseName: "service",
      type: "string",
    },
    {
      name: "tags",
      baseName: "tags",
      type: "Array<string>",
    },
    {
      name: "fields",
      baseName: "fields",
      type: "{ [key: string]: CommonObjectField; }",
    },
  ];

  static getAttributeTypeMap() {
    return CommonObjectDoc.attributeTypeMap;
  }
}

/**
 * ObjectField is a field of an Object.
 */
export class CommonObjectField {
  "name"?: string;
  "type"?: CommonObjectFieldType;
  "stringValue"?: string;
  "intValue"?: number;
  "floatValue"?: number;
  "boolValue"?: boolean;
  /**
   * Date is defined by milliseconds since epoch.
   */
  "dateValue"?: string;
  "blobValue"?: string;
  "referenceValue"?: string;
  "metadata"?: { [key: string]: string };

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "type",
      baseName: "type",
      type: "CommonObjectFieldType",
    },
    {
      name: "stringValue",
      baseName: "stringValue",
      type: "string",
    },
    {
      name: "intValue",
      baseName: "intValue",
      type: "number",
    },
    {
      name: "floatValue",
      baseName: "floatValue",
      type: "number",
    },
    {
      name: "boolValue",
      baseName: "boolValue",
      type: "boolean",
    },
    {
      name: "dateValue",
      baseName: "dateValue",
      type: "string",
    },
    {
      name: "blobValue",
      baseName: "blobValue",
      type: "string",
    },
    {
      name: "referenceValue",
      baseName: "referenceValue",
      type: "string",
    },
    {
      name: "metadata",
      baseName: "metadata",
      type: "{ [key: string]: string; }",
    },
  ];

  static getAttributeTypeMap() {
    return CommonObjectField.attributeTypeMap;
  }
}

/**
 * - OBJECT_FIELD_TYPE_UNSPECIFIED: ObjectFieldTypeUnspecified is the default value  - OBJECT_FIELD_TYPE_STRING: ObjectFieldTypeString is a string or text field  - OBJECT_FIELD_TYPE_INT: ObjectFieldTypeInt is an integer  - OBJECT_FIELD_TYPE_FLOAT: ObjectFieldTypeFloat is a floating point number  - OBJECT_FIELD_TYPE_BOOL: ObjectFieldTypeBool is a boolean  - OBJECT_FIELD_TYPE_DATETIME: ObjectFieldTypeDateTime is a datetime  - OBJECT_FIELD_TYPE_BLOB: ObjectFieldTypeBlob is a blob which is a byte array  - OBJECT_FIELD_TYPE_REFERENCE: ObjectFieldTypeReference is a reference to another object
 */
export class CommonObjectFieldType {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return CommonObjectFieldType.attributeTypeMap;
  }
}

export class CommonPayload {
  "items"?: Array<PayloadItem>;
  "owner"?: CommonProfile;
  "size"?: string;
  "createdAt"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "items",
      baseName: "items",
      type: "Array<PayloadItem>",
    },
    {
      name: "owner",
      baseName: "owner",
      type: "CommonProfile",
    },
    {
      name: "size",
      baseName: "size",
      type: "string",
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return CommonPayload.attributeTypeMap;
  }
}

export class CommonPeer {
  "sName"?: string;
  "status"?: CommonPeerStatus;
  "device"?: PeerDevice;
  "profile"?: CommonProfile;
  "publicKey"?: string;
  "peerId"?: string;
  "lastModified"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "sName",
      baseName: "sName",
      type: "string",
    },
    {
      name: "status",
      baseName: "status",
      type: "CommonPeerStatus",
    },
    {
      name: "device",
      baseName: "device",
      type: "PeerDevice",
    },
    {
      name: "profile",
      baseName: "profile",
      type: "CommonProfile",
    },
    {
      name: "publicKey",
      baseName: "publicKey",
      type: "string",
    },
    {
      name: "peerId",
      baseName: "peerId",
      type: "string",
    },
    {
      name: "lastModified",
      baseName: "lastModified",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return CommonPeer.attributeTypeMap;
  }
}

export class CommonPeerStatus {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return CommonPeerStatus.attributeTypeMap;
  }
}

export class CommonProfile {
  "sName"?: string;
  "firstName"?: string;
  "lastName"?: string;
  "picture"?: string;
  "bio"?: string;
  "lastModified"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "sName",
      baseName: "sName",
      type: "string",
    },
    {
      name: "firstName",
      baseName: "firstName",
      type: "string",
    },
    {
      name: "lastName",
      baseName: "lastName",
      type: "string",
    },
    {
      name: "picture",
      baseName: "picture",
      type: "string",
    },
    {
      name: "bio",
      baseName: "bio",
      type: "string",
    },
    {
      name: "lastModified",
      baseName: "lastModified",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return CommonProfile.attributeTypeMap;
  }
}

/**
 * Service is a Application that runs on the Sonr network.
 */
export class CommonService {
  /**
   * ID is the DID of the service.
   */
  "id"?: string;
  /**
   * Type is the type of the service.
   */
  "type"?: string;
  /**
   * ServiceEndpoint is the endpoint of the service.
   */
  "serviceEndpoint"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
    {
      name: "type",
      baseName: "type",
      type: "string",
    },
    {
      name: "serviceEndpoint",
      baseName: "serviceEndpoint",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return CommonService.attributeTypeMap;
  }
}

export class CommonSupplyItem {
  "path"?: string;
  "thumbnail"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "path",
      baseName: "path",
      type: "string",
    },
    {
      name: "thumbnail",
      baseName: "thumbnail",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return CommonSupplyItem.attributeTypeMap;
  }
}

export class CommonThumbnail {
  "buffer"?: string;
  "mime"?: CommonMIME;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "buffer",
      baseName: "buffer",
      type: "string",
    },
    {
      name: "mime",
      baseName: "mime",
      type: "CommonMIME",
    },
  ];

  static getAttributeTypeMap() {
    return CommonThumbnail.attributeTypeMap;
  }
}

/**
 * VerificationMethod is a method that can be used to verify the DID.
 */
export class CommonVerificationMethod {
  /**
   * ID is the DID of the verification method.
   */
  "id"?: string;
  /**
   * Type is the type of the verification method.
   */
  "type"?: string;
  /**
   * Controller is the DID of the controller of the verification method.
   */
  "controller"?: string;
  /**
   * PublicKeyHex is the public key of the verification method in hexidecimal.
   */
  "publicKeyHex"?: string;
  /**
   * PublicKeyBase58 is the public key of the verification method in base58.
   */
  "publicKeyBase58"?: string;
  /**
   * BlockchainAccountId is the blockchain account id of the verification method.
   */
  "blockchainAccountId"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
    {
      name: "type",
      baseName: "type",
      type: "string",
    },
    {
      name: "controller",
      baseName: "controller",
      type: "string",
    },
    {
      name: "publicKeyHex",
      baseName: "publicKeyHex",
      type: "string",
    },
    {
      name: "publicKeyBase58",
      baseName: "publicKeyBase58",
      type: "string",
    },
    {
      name: "blockchainAccountId",
      baseName: "blockchainAccountId",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return CommonVerificationMethod.attributeTypeMap;
  }
}

export class GooglerpcStatus {
  "code"?: number;
  "message"?: string;
  "details"?: Array<ProtobufAny>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "details",
      baseName: "details",
      type: "Array<ProtobufAny>",
    },
  ];

  static getAttributeTypeMap() {
    return GooglerpcStatus.attributeTypeMap;
  }
}

export class PayloadItem {
  "mime"?: CommonMIME;
  "size"?: string;
  "file"?: CommonFileItem;
  "url"?: string;
  "message"?: string;
  "thumbnail"?: CommonThumbnail;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "mime",
      baseName: "mime",
      type: "CommonMIME",
    },
    {
      name: "size",
      baseName: "size",
      type: "string",
    },
    {
      name: "file",
      baseName: "file",
      type: "CommonFileItem",
    },
    {
      name: "url",
      baseName: "url",
      type: "string",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "thumbnail",
      baseName: "thumbnail",
      type: "CommonThumbnail",
    },
  ];

  static getAttributeTypeMap() {
    return PayloadItem.attributeTypeMap;
  }
}

export class PeerDevice {
  "id"?: string;
  "hostName"?: string;
  "os"?: string;
  "arch"?: string;
  "model"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
    {
      name: "hostName",
      baseName: "hostName",
      type: "string",
    },
    {
      name: "os",
      baseName: "os",
      type: "string",
    },
    {
      name: "arch",
      baseName: "arch",
      type: "string",
    },
    {
      name: "model",
      baseName: "model",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return PeerDevice.attributeTypeMap;
  }
}

export class ProtobufAny extends null<String, any> {
  "type"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "type",
      baseName: "@type",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(ProtobufAny.attributeTypeMap);
  }
}

export class V1AccessNameResponse {
  "code"?: number;
  "message"?: string;
  "peer"?: CommonPeer;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "peer",
      baseName: "peer",
      type: "CommonPeer",
    },
  ];

  static getAttributeTypeMap() {
    return V1AccessNameResponse.attributeTypeMap;
  }
}

export class V1AccessServiceResponse {
  "code"?: number;
  "message"?: string;
  "metadata"?: { [key: string]: string };

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "metadata",
      baseName: "metadata",
      type: "{ [key: string]: string; }",
    },
  ];

  static getAttributeTypeMap() {
    return V1AccessServiceResponse.attributeTypeMap;
  }
}

export class V1CreateBucketResponse {
  "code"?: number;
  "message"?: string;
  "did"?: CommonDid;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "did",
      baseName: "did",
      type: "CommonDid",
    },
  ];

  static getAttributeTypeMap() {
    return V1CreateBucketResponse.attributeTypeMap;
  }
}

export class V1CreateChannelResponse {
  "code"?: number;
  "message"?: string;
  "did"?: CommonDid;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "did",
      baseName: "did",
      type: "CommonDid",
    },
  ];

  static getAttributeTypeMap() {
    return V1CreateChannelResponse.attributeTypeMap;
  }
}

export class V1CreateObjectResponse {
  "code"?: number;
  "message"?: string;
  "did"?: CommonDid;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "did",
      baseName: "did",
      type: "CommonDid",
    },
  ];

  static getAttributeTypeMap() {
    return V1CreateObjectResponse.attributeTypeMap;
  }
}

export class V1DecideResponse {
  "success"?: boolean;
  "error"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "success",
      baseName: "success",
      type: "boolean",
    },
    {
      name: "error",
      baseName: "error",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return V1DecideResponse.attributeTypeMap;
  }
}

export class V1DeleteBlobResponse {
  "code"?: number;
  "message"?: string;
  "did"?: CommonDid;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "did",
      baseName: "did",
      type: "CommonDid",
    },
  ];

  static getAttributeTypeMap() {
    return V1DeleteBlobResponse.attributeTypeMap;
  }
}

export class V1DeleteBucketResponse {
  "code"?: number;
  "message"?: string;
  "did"?: CommonDid;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "did",
      baseName: "did",
      type: "CommonDid",
    },
  ];

  static getAttributeTypeMap() {
    return V1DeleteBucketResponse.attributeTypeMap;
  }
}

export class V1DeleteChannelResponse {
  "code"?: number;
  "message"?: string;
  "did"?: CommonDid;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "did",
      baseName: "did",
      type: "CommonDid",
    },
  ];

  static getAttributeTypeMap() {
    return V1DeleteChannelResponse.attributeTypeMap;
  }
}

export class V1DeleteObjectResponse {
  "code"?: number;
  "message"?: string;
  "did"?: CommonDid;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "did",
      baseName: "did",
      type: "CommonDid",
    },
  ];

  static getAttributeTypeMap() {
    return V1DeleteObjectResponse.attributeTypeMap;
  }
}

export class V1DownloadBlobResponse {
  "code"?: number;
  "message"?: string;
  "did"?: CommonDid;
  "path"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "did",
      baseName: "did",
      type: "CommonDid",
    },
    {
      name: "path",
      baseName: "path",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return V1DownloadBlobResponse.attributeTypeMap;
  }
}

export class V1ListenBucketResponse {
  "code"?: number;
  "did"?: CommonDid;
  "metadata"?: { [key: string]: string };
  "objects"?: Array<CommonObjectDoc>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "did",
      baseName: "did",
      type: "CommonDid",
    },
    {
      name: "metadata",
      baseName: "metadata",
      type: "{ [key: string]: string; }",
    },
    {
      name: "objects",
      baseName: "objects",
      type: "Array<CommonObjectDoc>",
    },
  ];

  static getAttributeTypeMap() {
    return V1ListenBucketResponse.attributeTypeMap;
  }
}

export class V1ListenChannelResponse {
  "code"?: number;
  "did"?: CommonDid;
  "metadata"?: { [key: string]: string };
  "message"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "did",
      baseName: "did",
      type: "CommonDid",
    },
    {
      name: "metadata",
      baseName: "metadata",
      type: "{ [key: string]: string; }",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return V1ListenChannelResponse.attributeTypeMap;
  }
}

export class V1OnLobbyRefreshResponse {
  "olc"?: string;
  "peers"?: Array<CommonPeer>;
  "received"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "olc",
      baseName: "olc",
      type: "string",
    },
    {
      name: "peers",
      baseName: "peers",
      type: "Array<CommonPeer>",
    },
    {
      name: "received",
      baseName: "received",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return V1OnLobbyRefreshResponse.attributeTypeMap;
  }
}

export class V1OnMailboxMessageResponse {
  "id"?: string;
  "buffer"?: string;
  "from"?: CommonProfile;
  "to"?: CommonProfile;
  "metadata"?: CommonMetadata;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
    {
      name: "buffer",
      baseName: "buffer",
      type: "string",
    },
    {
      name: "from",
      baseName: "from",
      type: "CommonProfile",
    },
    {
      name: "to",
      baseName: "to",
      type: "CommonProfile",
    },
    {
      name: "metadata",
      baseName: "metadata",
      type: "CommonMetadata",
    },
  ];

  static getAttributeTypeMap() {
    return V1OnMailboxMessageResponse.attributeTypeMap;
  }
}

export class V1OnTransmitCompleteResponse {
  "direction"?: CommonDirection;
  "payload"?: CommonPayload;
  "from"?: CommonPeer;
  "to"?: CommonPeer;
  "createdAt"?: string;
  "receivedAt"?: string;
  "results"?: { [key: string]: boolean };

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "direction",
      baseName: "direction",
      type: "CommonDirection",
    },
    {
      name: "payload",
      baseName: "payload",
      type: "CommonPayload",
    },
    {
      name: "from",
      baseName: "from",
      type: "CommonPeer",
    },
    {
      name: "to",
      baseName: "to",
      type: "CommonPeer",
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "string",
    },
    {
      name: "receivedAt",
      baseName: "receivedAt",
      type: "string",
    },
    {
      name: "results",
      baseName: "results",
      type: "{ [key: string]: boolean; }",
    },
  ];

  static getAttributeTypeMap() {
    return V1OnTransmitCompleteResponse.attributeTypeMap;
  }
}

/**
 * DecisionEvent is emitted when a decision is made by Peer.
 */
export class V1OnTransmitDecisionResponse {
  "decision"?: boolean;
  "from"?: CommonPeer;
  "received"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "decision",
      baseName: "decision",
      type: "boolean",
    },
    {
      name: "from",
      baseName: "from",
      type: "CommonPeer",
    },
    {
      name: "received",
      baseName: "received",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return V1OnTransmitDecisionResponse.attributeTypeMap;
  }
}

export class V1OnTransmitInviteResponse {
  "received"?: string;
  "from"?: CommonPeer;
  "payload"?: CommonPayload;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "received",
      baseName: "received",
      type: "string",
    },
    {
      name: "from",
      baseName: "from",
      type: "CommonPeer",
    },
    {
      name: "payload",
      baseName: "payload",
      type: "CommonPayload",
    },
  ];

  static getAttributeTypeMap() {
    return V1OnTransmitInviteResponse.attributeTypeMap;
  }
}

export class V1OnTransmitProgressResponse {
  "progress"?: number;
  "received"?: string;
  "current"?: number;
  "total"?: number;
  "direction"?: CommonDirection;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "progress",
      baseName: "progress",
      type: "number",
    },
    {
      name: "received",
      baseName: "received",
      type: "string",
    },
    {
      name: "current",
      baseName: "current",
      type: "number",
    },
    {
      name: "total",
      baseName: "total",
      type: "number",
    },
    {
      name: "direction",
      baseName: "direction",
      type: "CommonDirection",
    },
  ];

  static getAttributeTypeMap() {
    return V1OnTransmitProgressResponse.attributeTypeMap;
  }
}

export class V1ParseDidResponse {
  "code"?: number;
  "message"?: string;
  "did"?: CommonDid;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "did",
      baseName: "did",
      type: "CommonDid",
    },
  ];

  static getAttributeTypeMap() {
    return V1ParseDidResponse.attributeTypeMap;
  }
}

export class V1ReadBucketResponse {
  "code"?: number;
  "message"?: string;
  "did"?: CommonDid;
  "objects"?: Array<CommonObjectDoc>;
  "owners"?: Array<CommonPeer>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "did",
      baseName: "did",
      type: "CommonDid",
    },
    {
      name: "objects",
      baseName: "objects",
      type: "Array<CommonObjectDoc>",
    },
    {
      name: "owners",
      baseName: "owners",
      type: "Array<CommonPeer>",
    },
  ];

  static getAttributeTypeMap() {
    return V1ReadBucketResponse.attributeTypeMap;
  }
}

export class V1ReadChannelResponse {
  "code"?: number;
  "message"?: string;
  "did"?: CommonDid;
  "subscribers"?: Array<CommonPeer>;
  "owners"?: Array<CommonPeer>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "did",
      baseName: "did",
      type: "CommonDid",
    },
    {
      name: "subscribers",
      baseName: "subscribers",
      type: "Array<CommonPeer>",
    },
    {
      name: "owners",
      baseName: "owners",
      type: "Array<CommonPeer>",
    },
  ];

  static getAttributeTypeMap() {
    return V1ReadChannelResponse.attributeTypeMap;
  }
}

export class V1ReadObjectResponse {
  "code"?: number;
  "message"?: string;
  "did"?: CommonDid;
  "object"?: CommonObjectDoc;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "did",
      baseName: "did",
      type: "CommonDid",
    },
    {
      name: "object",
      baseName: "object",
      type: "CommonObjectDoc",
    },
  ];

  static getAttributeTypeMap() {
    return V1ReadObjectResponse.attributeTypeMap;
  }
}

export class V1RegisterNameResponse {
  "code"?: number;
  "message"?: string;
  "didDocument"?: CommonDidDocument;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "didDocument",
      baseName: "didDocument",
      type: "CommonDidDocument",
    },
  ];

  static getAttributeTypeMap() {
    return V1RegisterNameResponse.attributeTypeMap;
  }
}

export class V1RegisterServiceResponse {
  "code"?: number;
  "message"?: string;
  "didDocument"?: CommonDidDocument;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "didDocument",
      baseName: "didDocument",
      type: "CommonDidDocument",
    },
  ];

  static getAttributeTypeMap() {
    return V1RegisterServiceResponse.attributeTypeMap;
  }
}

export class V1ResolveDidResponse {
  "code"?: number;
  "message"?: string;
  "didDocument"?: CommonDidDocument;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "didDocument",
      baseName: "didDocument",
      type: "CommonDidDocument",
    },
  ];

  static getAttributeTypeMap() {
    return V1ResolveDidResponse.attributeTypeMap;
  }
}

export class V1SearchResponse {
  "success"?: boolean;
  "error"?: string;
  "peer"?: CommonPeer;
  "peerId"?: string;
  "sName"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "success",
      baseName: "success",
      type: "boolean",
    },
    {
      name: "error",
      baseName: "error",
      type: "string",
    },
    {
      name: "peer",
      baseName: "peer",
      type: "CommonPeer",
    },
    {
      name: "peerId",
      baseName: "peerId",
      type: "string",
    },
    {
      name: "sName",
      baseName: "sName",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return V1SearchResponse.attributeTypeMap;
  }
}

export class V1ShareResponse {
  "success"?: boolean;
  "error"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "success",
      baseName: "success",
      type: "boolean",
    },
    {
      name: "error",
      baseName: "error",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return V1ShareResponse.attributeTypeMap;
  }
}

export class V1SyncBlobResponse {
  "code"?: number;
  "message"?: string;
  "did"?: CommonDid;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "did",
      baseName: "did",
      type: "CommonDid",
    },
  ];

  static getAttributeTypeMap() {
    return V1SyncBlobResponse.attributeTypeMap;
  }
}

export class V1UpdateBucketResponse {
  "code"?: number;
  "message"?: string;
  "did"?: CommonDid;
  "objects"?: Array<CommonObjectDoc>;
  "owners"?: Array<CommonPeer>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "did",
      baseName: "did",
      type: "CommonDid",
    },
    {
      name: "objects",
      baseName: "objects",
      type: "Array<CommonObjectDoc>",
    },
    {
      name: "owners",
      baseName: "owners",
      type: "Array<CommonPeer>",
    },
  ];

  static getAttributeTypeMap() {
    return V1UpdateBucketResponse.attributeTypeMap;
  }
}

export class V1UpdateChannelResponse {
  "code"?: number;
  "message"?: string;
  "did"?: CommonDid;
  "subscribers"?: Array<CommonPeer>;
  "owners"?: Array<CommonPeer>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "did",
      baseName: "did",
      type: "CommonDid",
    },
    {
      name: "subscribers",
      baseName: "subscribers",
      type: "Array<CommonPeer>",
    },
    {
      name: "owners",
      baseName: "owners",
      type: "Array<CommonPeer>",
    },
  ];

  static getAttributeTypeMap() {
    return V1UpdateChannelResponse.attributeTypeMap;
  }
}

export class V1UpdateNameResponse {
  "code"?: number;
  "message"?: string;
  "did"?: CommonDid;
  "metadata"?: { [key: string]: string };

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "did",
      baseName: "did",
      type: "CommonDid",
    },
    {
      name: "metadata",
      baseName: "metadata",
      type: "{ [key: string]: string; }",
    },
  ];

  static getAttributeTypeMap() {
    return V1UpdateNameResponse.attributeTypeMap;
  }
}

export class V1UpdateObjectResponse {
  "code"?: number;
  "message"?: string;
  "did"?: CommonDid;
  "object"?: CommonObjectDoc;
  "metadata"?: { [key: string]: string };

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "did",
      baseName: "did",
      type: "CommonDid",
    },
    {
      name: "object",
      baseName: "object",
      type: "CommonObjectDoc",
    },
    {
      name: "metadata",
      baseName: "metadata",
      type: "{ [key: string]: string; }",
    },
  ];

  static getAttributeTypeMap() {
    return V1UpdateObjectResponse.attributeTypeMap;
  }
}

export class V1UpdateServiceResponse {
  "code"?: number;
  "message"?: string;
  "did"?: CommonDid;
  "metadata"?: { [key: string]: string };

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "did",
      baseName: "did",
      type: "CommonDid",
    },
    {
      name: "metadata",
      baseName: "metadata",
      type: "{ [key: string]: string; }",
    },
  ];

  static getAttributeTypeMap() {
    return V1UpdateServiceResponse.attributeTypeMap;
  }
}

export class V1UploadBlobResponse {
  "code"?: number;
  "message"?: string;
  "did"?: CommonDid;
  "pinned"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "did",
      baseName: "did",
      type: "CommonDid",
    },
    {
      name: "pinned",
      baseName: "pinned",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return V1UploadBlobResponse.attributeTypeMap;
  }
}

let enumsMap: { [index: string]: any } = {};

let typeMap: { [index: string]: any } = {
  CommonBucketType: CommonBucketType,
  CommonDid: CommonDid,
  CommonDidDocument: CommonDidDocument,
  CommonDirection: CommonDirection,
  CommonFileItem: CommonFileItem,
  CommonMIME: CommonMIME,
  CommonMIMEType: CommonMIMEType,
  CommonMetadata: CommonMetadata,
  CommonObjectDoc: CommonObjectDoc,
  CommonObjectField: CommonObjectField,
  CommonObjectFieldType: CommonObjectFieldType,
  CommonPayload: CommonPayload,
  CommonPeer: CommonPeer,
  CommonPeerStatus: CommonPeerStatus,
  CommonProfile: CommonProfile,
  CommonService: CommonService,
  CommonSupplyItem: CommonSupplyItem,
  CommonThumbnail: CommonThumbnail,
  CommonVerificationMethod: CommonVerificationMethod,
  GooglerpcStatus: GooglerpcStatus,
  PayloadItem: PayloadItem,
  PeerDevice: PeerDevice,
  ProtobufAny: ProtobufAny,
  V1AccessNameResponse: V1AccessNameResponse,
  V1AccessServiceResponse: V1AccessServiceResponse,
  V1CreateBucketResponse: V1CreateBucketResponse,
  V1CreateChannelResponse: V1CreateChannelResponse,
  V1CreateObjectResponse: V1CreateObjectResponse,
  V1DecideResponse: V1DecideResponse,
  V1DeleteBlobResponse: V1DeleteBlobResponse,
  V1DeleteBucketResponse: V1DeleteBucketResponse,
  V1DeleteChannelResponse: V1DeleteChannelResponse,
  V1DeleteObjectResponse: V1DeleteObjectResponse,
  V1DownloadBlobResponse: V1DownloadBlobResponse,
  V1ListenBucketResponse: V1ListenBucketResponse,
  V1ListenChannelResponse: V1ListenChannelResponse,
  V1OnLobbyRefreshResponse: V1OnLobbyRefreshResponse,
  V1OnMailboxMessageResponse: V1OnMailboxMessageResponse,
  V1OnTransmitCompleteResponse: V1OnTransmitCompleteResponse,
  V1OnTransmitDecisionResponse: V1OnTransmitDecisionResponse,
  V1OnTransmitInviteResponse: V1OnTransmitInviteResponse,
  V1OnTransmitProgressResponse: V1OnTransmitProgressResponse,
  V1ParseDidResponse: V1ParseDidResponse,
  V1ReadBucketResponse: V1ReadBucketResponse,
  V1ReadChannelResponse: V1ReadChannelResponse,
  V1ReadObjectResponse: V1ReadObjectResponse,
  V1RegisterNameResponse: V1RegisterNameResponse,
  V1RegisterServiceResponse: V1RegisterServiceResponse,
  V1ResolveDidResponse: V1ResolveDidResponse,
  V1SearchResponse: V1SearchResponse,
  V1ShareResponse: V1ShareResponse,
  V1SyncBlobResponse: V1SyncBlobResponse,
  V1UpdateBucketResponse: V1UpdateBucketResponse,
  V1UpdateChannelResponse: V1UpdateChannelResponse,
  V1UpdateNameResponse: V1UpdateNameResponse,
  V1UpdateObjectResponse: V1UpdateObjectResponse,
  V1UpdateServiceResponse: V1UpdateServiceResponse,
  V1UploadBlobResponse: V1UploadBlobResponse,
};

export interface Authentication {
  /**
   * Apply authentication settings to header and query params.
   */
  applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
  public username: string = "";
  public password: string = "";

  applyToRequest(requestOptions: localVarRequest.Options): void {
    requestOptions.auth = {
      username: this.username,
      password: this.password,
    };
  }
}

export class ApiKeyAuth implements Authentication {
  public apiKey: string = "";

  constructor(private location: string, private paramName: string) {}

  applyToRequest(requestOptions: localVarRequest.Options): void {
    if (this.location == "query") {
      (<any>requestOptions.qs)[this.paramName] = this.apiKey;
    } else if (
      this.location == "header" &&
      requestOptions &&
      requestOptions.headers
    ) {
      requestOptions.headers[this.paramName] = this.apiKey;
    }
  }
}

export class OAuth implements Authentication {
  public accessToken: string = "";

  applyToRequest(requestOptions: localVarRequest.Options): void {
    if (requestOptions && requestOptions.headers) {
      requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
  }
}

export class VoidAuth implements Authentication {
  public username: string = "";
  public password: string = "";

  applyToRequest(_: localVarRequest.Options): void {
    // Do nothing
  }
}

export enum HighwayServiceApiApiKeys {}

export class HighwayServiceApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: HighwayServiceApiApiKeys, value: string) {
    (this.authentications as any)[HighwayServiceApiApiKeys[key]].apiKey = value;
  }
  /**
   *
   * @summary AccessName returns details and publicly available information about the Peer given calling node has permission to access. i.e \"prad.snr\" -> \"firstname online profilePic city\"
   * @param name The name of the peer to get the details from.
   * @param publicKey The public key of the peer to get the details from.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceAccessName(
    name?: string,
    publicKey?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: V1AccessNameResponse }> {
    const localVarPath = this.basePath + "/v1/name/access";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (name !== undefined) {
      localVarQueryParameters["name"] = ObjectSerializer.serialize(
        name,
        "string"
      );
    }

    if (publicKey !== undefined) {
      localVarQueryParameters["publicKey"] = ObjectSerializer.serialize(
        publicKey,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: V1AccessNameResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "V1AccessNameResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary AccessService creates a new signing key for the calling node in order to be authorized to access the service. It is only allowed to be called once per node.
   * @param did The name of the peer to get the service details of.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceAccessService(
    did?: string,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: V1AccessServiceResponse;
  }> {
    const localVarPath = this.basePath + "/v1/service/access";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (did !== undefined) {
      localVarQueryParameters["did"] = ObjectSerializer.serialize(
        did,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: V1AccessServiceResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "V1AccessServiceResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary CreateBucket creates a new bucket for the calling nodes service.
   * @param label Label is the human-readable name of the bucket.
   * @param description Description is the description of the bucket.
   * @param bucketType Owners is the list of provisioned nodes for the bucket.   - BUCKET_TYPE_UNSPECIFIED: BucketTypeUnspecified is the default value.  - BUCKET_TYPE_APP: BucketTypeApp is an App specific bucket. For Assets regarding the service.  - BUCKET_TYPE_USER: BucketTypeUser is a User specific bucket. For any remote user data that is required to be stored in the Network.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceCreateBucket(
    label?: string,
    description?: string,
    bucketType?:
      | "BUCKET_TYPE_UNSPECIFIED"
      | "BUCKET_TYPE_APP"
      | "BUCKET_TYPE_USER",
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: V1CreateBucketResponse }> {
    const localVarPath = this.basePath + "/v1/bucket/create";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (label !== undefined) {
      localVarQueryParameters["label"] = ObjectSerializer.serialize(
        label,
        "string"
      );
    }

    if (description !== undefined) {
      localVarQueryParameters["description"] = ObjectSerializer.serialize(
        description,
        "string"
      );
    }

    if (bucketType !== undefined) {
      localVarQueryParameters["bucketType"] = ObjectSerializer.serialize(
        bucketType,
        "'BUCKET_TYPE_UNSPECIFIED' | 'BUCKET_TYPE_APP' | 'BUCKET_TYPE_USER'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: V1CreateBucketResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "V1CreateBucketResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary CreateChannel creates a new Publish/Subscribe topic channel for the given service. The calling node must have already registered a service for the channel.
   * @param name Name is the name of the channel.
   * @param description Description is the description of the channel.
   * @param owners Owners is the list of provisioned nodes for the channel.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceCreateChannel(
    name?: string,
    description?: string,
    owners?: Array<string>,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: V1CreateChannelResponse;
  }> {
    const localVarPath = this.basePath + "/v1/channel/create";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (name !== undefined) {
      localVarQueryParameters["name"] = ObjectSerializer.serialize(
        name,
        "string"
      );
    }

    if (description !== undefined) {
      localVarQueryParameters["description"] = ObjectSerializer.serialize(
        description,
        "string"
      );
    }

    if (owners !== undefined) {
      localVarQueryParameters["owners"] = ObjectSerializer.serialize(
        owners,
        "Array<string>"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: V1CreateChannelResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "V1CreateChannelResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary CreateObject defines a new object to be utilized by the calling node's service. The object will be placed in the Highway Service Graph and can be used in channels and other modules.
   * @param label Label is the label of the object.
   * @param name Name is the name of the object.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceCreateObject(
    label?: string,
    name?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: V1CreateObjectResponse }> {
    const localVarPath = this.basePath + "/v1/object/create";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (label !== undefined) {
      localVarQueryParameters["label"] = ObjectSerializer.serialize(
        label,
        "string"
      );
    }

    if (name !== undefined) {
      localVarQueryParameters["name"] = ObjectSerializer.serialize(
        name,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: V1CreateObjectResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "V1CreateObjectResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary DeleteBlob deletes the given file from the calling node's service IPFS storage.
   * @param did DID is the identifier of the blob.
   * @param publicKey Public key of the node that is deleting the blob.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceDeleteBlob(
    did?: string,
    publicKey?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: V1DeleteBlobResponse }> {
    const localVarPath = this.basePath + "/v1/blob/delete";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (did !== undefined) {
      localVarQueryParameters["did"] = ObjectSerializer.serialize(
        did,
        "string"
      );
    }

    if (publicKey !== undefined) {
      localVarQueryParameters["publicKey"] = ObjectSerializer.serialize(
        publicKey,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: V1DeleteBlobResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "V1DeleteBlobResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary DeleteBucket deletes the given bucket if the calling node is the owner of the bucket.
   * @param did DID is the DID of the bucket.
   * @param publicKey Public key of the node that is deleting the bucket.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceDeleteBucket(
    did?: string,
    publicKey?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: V1DeleteBucketResponse }> {
    const localVarPath = this.basePath + "/v1/bucket/delete";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (did !== undefined) {
      localVarQueryParameters["did"] = ObjectSerializer.serialize(
        did,
        "string"
      );
    }

    if (publicKey !== undefined) {
      localVarQueryParameters["publicKey"] = ObjectSerializer.serialize(
        publicKey,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: V1DeleteBucketResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "V1DeleteBucketResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary DeleteChannel deletes the given channel if the calling node is the owner of the channel.
   * @param did Did is the DID of the channel.
   * @param publicKey Public key of the node that is deleting the channel.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceDeleteChannel(
    did?: string,
    publicKey?: string,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: V1DeleteChannelResponse;
  }> {
    const localVarPath = this.basePath + "/v1/channel/delete";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (did !== undefined) {
      localVarQueryParameters["did"] = ObjectSerializer.serialize(
        did,
        "string"
      );
    }

    if (publicKey !== undefined) {
      localVarQueryParameters["publicKey"] = ObjectSerializer.serialize(
        publicKey,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: V1DeleteChannelResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "V1DeleteChannelResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary DeleteObject deletes the given object if the calling node is the owner of the object.
   * @param did DID is the identifier of the object.
   * @param publicKey Public key of the node that is deleting the object.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceDeleteObject(
    did?: string,
    publicKey?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: V1DeleteObjectResponse }> {
    const localVarPath = this.basePath + "/v1/object/delete";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (did !== undefined) {
      localVarQueryParameters["did"] = ObjectSerializer.serialize(
        did,
        "string"
      );
    }

    if (publicKey !== undefined) {
      localVarQueryParameters["publicKey"] = ObjectSerializer.serialize(
        publicKey,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: V1DeleteObjectResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "V1DeleteObjectResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary DownloadBlob downloads a file or buffer from the calling node's service IPFS storage.
   * @param did DID is the identifier of the blob.
   * @param outPath Out Path is the download path of the blob.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceDownloadBlob(
    did?: string,
    outPath?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: any }> {
    const localVarPath = this.basePath + "/v1/blob/download";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (did !== undefined) {
      localVarQueryParameters["did"] = ObjectSerializer.serialize(
        did,
        "string"
      );
    }

    if (outPath !== undefined) {
      localVarQueryParameters["outPath"] = ObjectSerializer.serialize(
        outPath,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "any");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary ListenBucket subscribes the calling node to the given bucket and returns all publish events as a stream.
   * @param did DID is the DID of the bucket.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceListenBucket(
    did?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: any }> {
    const localVarPath = this.basePath + "/v1/bucket/listen";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (did !== undefined) {
      localVarQueryParameters["did"] = ObjectSerializer.serialize(
        did,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "any");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary ListenChannel subscribes the calling node to the given channel and returns all publish events as a stream.
   * @param did Name is the name of the channel.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceListenChannel(
    did?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: any }> {
    const localVarPath = this.basePath + "/v1/channel/listen";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (did !== undefined) {
      localVarQueryParameters["did"] = ObjectSerializer.serialize(
        did,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "any");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary ParseDid parses a potential DID string into a DID object.
   * @param did DID is the DID of the DID.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceParseDid(
    did?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: V1ParseDidResponse }> {
    const localVarPath = this.basePath + "/v1/did/parse";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (did !== undefined) {
      localVarQueryParameters["did"] = ObjectSerializer.serialize(
        did,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: V1ParseDidResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "V1ParseDidResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary ReadBucket lists all the blobs in the given bucket. The calling node must have access to the bucket.
   * @param did DID is the identifier of the bucket.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceReadBucket(
    did?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: V1ReadBucketResponse }> {
    const localVarPath = this.basePath + "/v1/bucket/read";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (did !== undefined) {
      localVarQueryParameters["did"] = ObjectSerializer.serialize(
        did,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: V1ReadBucketResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "V1ReadBucketResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary ReadChannel lists all peers subscribed to the given channel, and additional details about the channels configuration.
   * @param did DID is the identifier of the channel.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceReadChannel(
    did?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: V1ReadChannelResponse }> {
    const localVarPath = this.basePath + "/v1/channel/read";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (did !== undefined) {
      localVarQueryParameters["did"] = ObjectSerializer.serialize(
        did,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: V1ReadChannelResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "V1ReadChannelResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary ReadObject returns the details of the given object provided its DID or Label.
   * @param did DID is the identifier of the object.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceReadObject(
    did?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: V1ReadObjectResponse }> {
    const localVarPath = this.basePath + "/v1/object/read";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (did !== undefined) {
      localVarQueryParameters["did"] = ObjectSerializer.serialize(
        did,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: V1ReadObjectResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "V1ReadObjectResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary RegisterName registers a new \".snr\" name for the calling node. It is only allowed to be called once per node.
   * @param deviceId The name of the peer to register the name with.
   * @param os The Operating System of the peer to register the name with.
   * @param model The model of the peer to register the name with.
   * @param arch The architecture of the peer to register the name with.
   * @param publicKey The public key of the peer to register the name with.
   * @param nameToRegister The name to register.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceRegisterName(
    deviceId?: string,
    os?: string,
    model?: string,
    arch?: string,
    publicKey?: string,
    nameToRegister?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: V1RegisterNameResponse }> {
    const localVarPath = this.basePath + "/v1/name/register";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (deviceId !== undefined) {
      localVarQueryParameters["deviceId"] = ObjectSerializer.serialize(
        deviceId,
        "string"
      );
    }

    if (os !== undefined) {
      localVarQueryParameters["os"] = ObjectSerializer.serialize(os, "string");
    }

    if (model !== undefined) {
      localVarQueryParameters["model"] = ObjectSerializer.serialize(
        model,
        "string"
      );
    }

    if (arch !== undefined) {
      localVarQueryParameters["arch"] = ObjectSerializer.serialize(
        arch,
        "string"
      );
    }

    if (publicKey !== undefined) {
      localVarQueryParameters["publicKey"] = ObjectSerializer.serialize(
        publicKey,
        "string"
      );
    }

    if (nameToRegister !== undefined) {
      localVarQueryParameters["nameToRegister"] = ObjectSerializer.serialize(
        nameToRegister,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: V1RegisterNameResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "V1RegisterNameResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary RegisterService registers a new service for the calling node. The calling node must have already been enabled for development.
   * @param serviceName The name of the peer to register the service with.
   * @param publicKey The public key of the peer to register the service with.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceRegisterService(
    serviceName?: string,
    publicKey?: string,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: V1RegisterServiceResponse;
  }> {
    const localVarPath = this.basePath + "/v1/service/register";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (serviceName !== undefined) {
      localVarQueryParameters["serviceName"] = ObjectSerializer.serialize(
        serviceName,
        "string"
      );
    }

    if (publicKey !== undefined) {
      localVarQueryParameters["publicKey"] = ObjectSerializer.serialize(
        publicKey,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: V1RegisterServiceResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "V1RegisterServiceResponse"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary ResolveDid resolves a DID to its DID document if the DID is valid and the calling node has access to the DID Document.
   * @param did DID is the DID of the DID.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceResolveDid(
    did?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: V1ResolveDidResponse }> {
    const localVarPath = this.basePath + "/v1/did/resolve";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (did !== undefined) {
      localVarQueryParameters["did"] = ObjectSerializer.serialize(
        did,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: V1ResolveDidResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "V1ResolveDidResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary SyncBlob synchronizes a local file from the calling node to the given service's IPFS storage.
   * @param did DID is the identifier of the blob.
   * @param destinationDid Destination DID is the identifier of the destination service storage.
   * @param path Path is the location of the blob.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceSyncBlob(
    did?: string,
    destinationDid?: string,
    path?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: any }> {
    const localVarPath = this.basePath + "/v1/blob/sync";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (did !== undefined) {
      localVarQueryParameters["did"] = ObjectSerializer.serialize(
        did,
        "string"
      );
    }

    if (destinationDid !== undefined) {
      localVarQueryParameters["destinationDid"] = ObjectSerializer.serialize(
        destinationDid,
        "string"
      );
    }

    if (path !== undefined) {
      localVarQueryParameters["path"] = ObjectSerializer.serialize(
        path,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "any");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary UpdateBucket updates the configuration of the given bucket. The calling node must have access to the bucket.
   * @param did DID is the DID of the bucket.
   * @param label Label is the human-readable name of the bucket.
   * @param description Description is the description of the bucket.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceUpdateBucket(
    did?: string,
    label?: string,
    description?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: V1UpdateBucketResponse }> {
    const localVarPath = this.basePath + "/v1/bucket/update";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (did !== undefined) {
      localVarQueryParameters["did"] = ObjectSerializer.serialize(
        did,
        "string"
      );
    }

    if (label !== undefined) {
      localVarQueryParameters["label"] = ObjectSerializer.serialize(
        label,
        "string"
      );
    }

    if (description !== undefined) {
      localVarQueryParameters["description"] = ObjectSerializer.serialize(
        description,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: V1UpdateBucketResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "V1UpdateBucketResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary UpdateChannel updates the configuration of the given channel.
   * @param did Did is the DID of the channel.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceUpdateChannel(
    did?: string,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: V1UpdateChannelResponse;
  }> {
    const localVarPath = this.basePath + "/v1/channel/update";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (did !== undefined) {
      localVarQueryParameters["did"] = ObjectSerializer.serialize(
        did,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: V1UpdateChannelResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "V1UpdateChannelResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary UpdateName updates the public information of the calling node.
   * @param name The name of the peer to update the name of.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceUpdateName(
    name?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: V1UpdateNameResponse }> {
    const localVarPath = this.basePath + "/v1/name/update";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (name !== undefined) {
      localVarQueryParameters["name"] = ObjectSerializer.serialize(
        name,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: V1UpdateNameResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "V1UpdateNameResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary UpdateObject modifies the property fields of the given object.
   * @param did DID is the identifier of the object.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceUpdateObject(
    did?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: V1UpdateObjectResponse }> {
    const localVarPath = this.basePath + "/v1/object/update";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (did !== undefined) {
      localVarQueryParameters["did"] = ObjectSerializer.serialize(
        did,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: V1UpdateObjectResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "V1UpdateObjectResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary UpdateService updates the details and public configuration of the calling node's service.
   * @param did The name of the peer to update the service details of.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceUpdateService(
    did?: string,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: V1UpdateServiceResponse;
  }> {
    const localVarPath = this.basePath + "/v1/service/update";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (did !== undefined) {
      localVarQueryParameters["did"] = ObjectSerializer.serialize(
        did,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: V1UpdateServiceResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "V1UpdateServiceResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary UploadBlob uploads a file or buffer to the calling node's service IPFS storage.
   * @param label Label is the label of the blob.
   * @param path Path is the path of the blob.
   * @param bucketDid Bucket is the bucket of the blob.
   * @param size Size is the size of the blob.
   * @param lastModified LastModified is the last modified time of the blob.
   * @param {*} [options] Override http request options.
   */
  public highwayServiceUploadBlob(
    label?: string,
    path?: string,
    bucketDid?: string,
    size?: string,
    lastModified?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: any }> {
    const localVarPath = this.basePath + "/v1/blob/upload";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (label !== undefined) {
      localVarQueryParameters["label"] = ObjectSerializer.serialize(
        label,
        "string"
      );
    }

    if (path !== undefined) {
      localVarQueryParameters["path"] = ObjectSerializer.serialize(
        path,
        "string"
      );
    }

    if (bucketDid !== undefined) {
      localVarQueryParameters["bucketDid"] = ObjectSerializer.serialize(
        bucketDid,
        "string"
      );
    }

    if (size !== undefined) {
      localVarQueryParameters["size"] = ObjectSerializer.serialize(
        size,
        "string"
      );
    }

    if (lastModified !== undefined) {
      localVarQueryParameters["lastModified"] = ObjectSerializer.serialize(
        lastModified,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "any");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
