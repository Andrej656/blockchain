// @generated by protobuf-ts 2.2.1 with parameter long_type_string,generate_dependencies
// @generated from protobuf file "object/object.proto" (package "sonrio.sonr.object", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * ObjectDoc is a document for an Object stored in the graph.
 *
 * @generated from protobuf message sonrio.sonr.object.ObjectDoc
 */
export interface ObjectDoc {
    /**
     * Label is human-readable name of the bucket.
     *
     * @generated from protobuf field: string label = 1;
     */
    label: string;
    /**
     * Description is a human-readable description of the bucket.
     *
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * Did is the identifier of the object.
     *
     * @generated from protobuf field: string did = 3;
     */
    did: string;
    /**
     * Bucket is the did of the bucket that contains this object.
     *
     * @generated from protobuf field: string bucket_did = 4;
     */
    bucketDid: string; // optional
    /**
     * Fields are the fields associated with the object.
     *
     * @generated from protobuf field: map<string, sonrio.sonr.object.ObjectField> fields = 5;
     */
    fields: {
        [key: string]: ObjectField;
    };
}
/**
 * ObjectField is a field of an Object.
 *
 * @generated from protobuf message sonrio.sonr.object.ObjectField
 */
export interface ObjectField {
    /**
     * Label is the name of the field
     *
     * @generated from protobuf field: string label = 1;
     */
    label: string;
    /**
     * Type is the type of the field
     *
     * @generated from protobuf field: sonrio.sonr.object.ObjectFieldType type = 2;
     */
    type: ObjectFieldType;
    /**
     * Did is the identifier of the field.
     *
     * @generated from protobuf field: string did = 3;
     */
    did: string;
    /**
     * @generated from protobuf oneof: value
     */
    value: {
        oneofKind: "stringValue";
        /**
         * String is the value of the field
         *
         * @generated from protobuf field: sonrio.sonr.object.ObjectFieldText string_value = 4;
         */
        stringValue: ObjectFieldText;
    } | {
        oneofKind: "numberValue";
        /**
         * Number is the value of the field
         *
         * @generated from protobuf field: sonrio.sonr.object.ObjectFieldNumber number_value = 5;
         */
        numberValue: ObjectFieldNumber;
    } | {
        oneofKind: "boolValue";
        /**
         * Float is the value of the field
         *
         * @generated from protobuf field: sonrio.sonr.object.ObjectFieldBool bool_value = 6;
         */
        boolValue: ObjectFieldBool;
    } | {
        oneofKind: "arrayValue";
        /**
         * Array is the value of the field
         *
         * @generated from protobuf field: sonrio.sonr.object.ObjectFieldArray array_value = 7;
         */
        arrayValue: ObjectFieldArray;
    } | {
        oneofKind: "timeStampValue";
        /**
         * Time is defined by milliseconds since epoch.
         *
         * @generated from protobuf field: sonrio.sonr.object.ObjectFieldTime time_stamp_value = 8;
         */
        timeStampValue: ObjectFieldTime;
    } | {
        oneofKind: "geopointValue";
        /**
         * Geopoint is the value of the field
         *
         * @generated from protobuf field: sonrio.sonr.object.ObjectFieldGeopoint geopoint_value = 9;
         */
        geopointValue: ObjectFieldGeopoint;
    } | {
        oneofKind: "blobValue";
        /**
         * Blob is the value of the field
         *
         * @generated from protobuf field: sonrio.sonr.object.ObjectFieldBlob blob_value = 10;
         */
        blobValue: ObjectFieldBlob;
    } | {
        oneofKind: "blockchainAddrValue";
        /**
         * Blockchain Address is the value of the field
         *
         * @generated from protobuf field: sonrio.sonr.object.ObjectFieldBlockchainAddress blockchain_addr_value = 12;
         */
        blockchainAddrValue: ObjectFieldBlockchainAddress;
    } | {
        oneofKind: undefined;
    };
    /**
     * Metadata is additional info about the field
     *
     * @generated from protobuf field: map<string, string> metadata = 13;
     */
    metadata: {
        [key: string]: string;
    };
}
/**
 * ObjectFieldArray is an array of ObjectFields to be stored in the graph object.
 *
 * @generated from protobuf message sonrio.sonr.object.ObjectFieldArray
 */
export interface ObjectFieldArray {
    /**
     * Label is the name of the field
     *
     * @generated from protobuf field: string label = 1;
     */
    label: string;
    /**
     * Type is the type of the field
     *
     * @generated from protobuf field: sonrio.sonr.object.ObjectFieldType type = 2;
     */
    type: ObjectFieldType;
    /**
     * Did is the identifier of the field.
     *
     * @generated from protobuf field: string did = 3;
     */
    did: string;
    /**
     * Entries are the values of the field
     *
     * @generated from protobuf field: repeated sonrio.sonr.object.ObjectField items = 4;
     */
    items: ObjectField[];
}
/**
 * ObjectFieldText is a text field of an Object.
 *
 * @generated from protobuf message sonrio.sonr.object.ObjectFieldText
 */
export interface ObjectFieldText {
    /**
     * Label is the name of the field
     *
     * @generated from protobuf field: string label = 1;
     */
    label: string;
    /**
     * Did is the identifier of the field.
     *
     * @generated from protobuf field: string did = 2;
     */
    did: string;
    /**
     * Value is the value of the field
     *
     * @generated from protobuf field: string value = 3;
     */
    value: string;
    /**
     * Metadata is additional info about the field
     *
     * @generated from protobuf field: map<string, string> metadata = 4;
     */
    metadata: {
        [key: string]: string;
    };
}
/**
 * ObjectFieldNumber is a number field of an Object.
 *
 * @generated from protobuf message sonrio.sonr.object.ObjectFieldNumber
 */
export interface ObjectFieldNumber {
    /**
     * Label is the name of the field
     *
     * @generated from protobuf field: string label = 1;
     */
    label: string;
    /**
     * Did is the identifier of the field.
     *
     * @generated from protobuf field: string did = 2;
     */
    did: string;
    /**
     * Value is the value of the field
     *
     * @generated from protobuf field: double value = 3;
     */
    value: number;
    /**
     * Metadata is additional info about the field
     *
     * @generated from protobuf field: map<string, string> metadata = 4;
     */
    metadata: {
        [key: string]: string;
    };
}
/**
 * ObjectFieldBool is a boolean field of an Object.
 *
 * @generated from protobuf message sonrio.sonr.object.ObjectFieldBool
 */
export interface ObjectFieldBool {
    /**
     * Label is the name of the field
     *
     * @generated from protobuf field: string label = 1;
     */
    label: string;
    /**
     * Did is the identifier of the field.
     *
     * @generated from protobuf field: string did = 2;
     */
    did: string;
    /**
     * Value is the value of the field
     *
     * @generated from protobuf field: bool value = 3;
     */
    value: boolean;
    /**
     * Metadata is additional info about the field
     *
     * @generated from protobuf field: map<string, string> metadata = 4;
     */
    metadata: {
        [key: string]: string;
    };
}
/**
 * ObjectFieldTime is a time field of an Object.
 *
 * @generated from protobuf message sonrio.sonr.object.ObjectFieldTime
 */
export interface ObjectFieldTime {
    /**
     * Label is the name of the field
     *
     * @generated from protobuf field: string label = 1;
     */
    label: string;
    /**
     * Did is the identifier of the field.
     *
     * @generated from protobuf field: string did = 2;
     */
    did: string;
    /**
     * Value is the value of the field
     *
     * @generated from protobuf field: int64 value = 3;
     */
    value: string;
    /**
     * Metadata is additional info about the field
     *
     * @generated from protobuf field: map<string, string> metadata = 4;
     */
    metadata: {
        [key: string]: string;
    };
}
/**
 * ObjectFieldGeopoint is a field of an Object for geopoints.
 *
 * @generated from protobuf message sonrio.sonr.object.ObjectFieldGeopoint
 */
export interface ObjectFieldGeopoint {
    /**
     * Label is the name of the field
     *
     * @generated from protobuf field: string label = 1;
     */
    label: string;
    /**
     * Type is the type of the field
     *
     * @generated from protobuf field: sonrio.sonr.object.ObjectFieldType type = 2;
     */
    type: ObjectFieldType;
    /**
     * Did is the identifier of the field.
     *
     * @generated from protobuf field: string did = 3;
     */
    did: string;
    /**
     * Latitude is the geo-latitude of the point.
     *
     * @generated from protobuf field: double latitude = 4;
     */
    latitude: number;
    /**
     * Longitude is the geo-longitude of the field
     *
     * @generated from protobuf field: double longitude = 5;
     */
    longitude: number;
    /**
     * Metadata is additional info about the field
     *
     * @generated from protobuf field: map<string, string> metadata = 6;
     */
    metadata: {
        [key: string]: string;
    };
}
/**
 * ObjectFieldBlob is a field of an Object for blobs.
 *
 * @generated from protobuf message sonrio.sonr.object.ObjectFieldBlob
 */
export interface ObjectFieldBlob {
    /**
     * Label is the name of the field
     *
     * @generated from protobuf field: string label = 1;
     */
    label: string;
    /**
     * Did is the identifier of the field.
     *
     * @generated from protobuf field: string did = 2;
     */
    did: string;
    /**
     * Value is the value of the field
     *
     * @generated from protobuf field: bytes value = 3;
     */
    value: Uint8Array;
    /**
     * Metadata is additional info about the field
     *
     * @generated from protobuf field: map<string, string> metadata = 4;
     */
    metadata: {
        [key: string]: string;
    };
}
/**
 * ObjectFieldBlockchainAddress is a field of an Object for blockchain addresses.
 *
 * @generated from protobuf message sonrio.sonr.object.ObjectFieldBlockchainAddress
 */
export interface ObjectFieldBlockchainAddress {
    /**
     * Label is the name of the field
     *
     * @generated from protobuf field: string label = 1;
     */
    label: string;
    /**
     * Did is the identifier of the field.
     *
     * @generated from protobuf field: string did = 2;
     */
    did: string;
    /**
     * Value is the value of the field
     *
     * @generated from protobuf field: string value = 3;
     */
    value: string;
    /**
     * Metadata is additional info about the field
     *
     * @generated from protobuf field: map<string, string> metadata = 4;
     */
    metadata: {
        [key: string]: string;
    };
}
/**
 * ObjectFieldType is the type of the field
 *
 * @generated from protobuf enum sonrio.sonr.object.ObjectFieldType
 */
export enum ObjectFieldType {
    /**
     * ObjectFieldTypeUnspecified is the default value
     *
     * @generated from protobuf enum value: OBJECT_FIELD_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * ObjectFieldTypeString is a string or text field
     *
     * @generated from protobuf enum value: OBJECT_FIELD_TYPE_STRING = 1;
     */
    STRING = 1,
    /**
     * ObjectFieldTypeInt is an integer
     *
     * @generated from protobuf enum value: OBJECT_FIELD_TYPE_NUMBER = 2;
     */
    NUMBER = 2,
    /**
     * ObjectFieldTypeBool is a boolean
     *
     * @generated from protobuf enum value: OBJECT_FIELD_TYPE_BOOL = 3;
     */
    BOOL = 3,
    /**
     * ObjectFieldTypeArray is a list of values
     *
     * @generated from protobuf enum value: OBJECT_FIELD_TYPE_ARRAY = 4;
     */
    ARRAY = 4,
    /**
     * ObjectFieldTypeDateTime is a datetime
     *
     * @generated from protobuf enum value: OBJECT_FIELD_TYPE_TIMESTAMP = 5;
     */
    TIMESTAMP = 5,
    /**
     * ObjectFieldTypeGeopoint is a geopoint
     *
     * @generated from protobuf enum value: OBJECT_FIELD_TYPE_GEOPOINT = 6;
     */
    GEOPOINT = 6,
    /**
     * ObjectFieldTypeBlob is a blob of data
     *
     * @generated from protobuf enum value: OBJECT_FIELD_TYPE_BLOB = 7;
     */
    BLOB = 7,
    /**
     * ObjectFieldTypeETU is a pointer to an Ethereum account address.
     *
     * @generated from protobuf enum value: OBJECT_FIELD_TYPE_BLOCKCHAIN_ADDRESS = 8;
     */
    BLOCKCHAIN_ADDRESS = 8
}
// @generated message type with reflection information, may provide speed optimized methods
class ObjectDoc$Type extends MessageType<ObjectDoc> {
    constructor() {
        super("sonrio.sonr.object.ObjectDoc", [
            { no: 1, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "did", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "bucket_did", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "fields", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => ObjectField } }
        ]);
    }
    create(value?: PartialMessage<ObjectDoc>): ObjectDoc {
        const message = { label: "", description: "", did: "", bucketDid: "", fields: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ObjectDoc>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ObjectDoc): ObjectDoc {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* string did */ 3:
                    message.did = reader.string();
                    break;
                case /* string bucket_did */ 4:
                    message.bucketDid = reader.string();
                    break;
                case /* map<string, sonrio.sonr.object.ObjectField> fields */ 5:
                    this.binaryReadMap5(message.fields, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: ObjectDoc["fields"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ObjectDoc["fields"] | undefined, val: ObjectDoc["fields"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = ObjectField.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field sonrio.sonr.object.ObjectDoc.fields");
            }
        }
        map[key ?? ""] = val ?? ObjectField.create();
    }
    internalBinaryWrite(message: ObjectDoc, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* string did = 3; */
        if (message.did !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.did);
        /* string bucket_did = 4; */
        if (message.bucketDid !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.bucketDid);
        /* map<string, sonrio.sonr.object.ObjectField> fields = 5; */
        for (let k of Object.keys(message.fields)) {
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            ObjectField.internalBinaryWrite(message.fields[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.object.ObjectDoc
 */
export const ObjectDoc = new ObjectDoc$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectField$Type extends MessageType<ObjectField> {
    constructor() {
        super("sonrio.sonr.object.ObjectField", [
            { no: 1, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["sonrio.sonr.object.ObjectFieldType", ObjectFieldType, "OBJECT_FIELD_TYPE_"] },
            { no: 3, name: "did", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "string_value", kind: "message", oneof: "value", T: () => ObjectFieldText },
            { no: 5, name: "number_value", kind: "message", oneof: "value", T: () => ObjectFieldNumber },
            { no: 6, name: "bool_value", kind: "message", oneof: "value", T: () => ObjectFieldBool },
            { no: 7, name: "array_value", kind: "message", oneof: "value", T: () => ObjectFieldArray },
            { no: 8, name: "time_stamp_value", kind: "message", oneof: "value", T: () => ObjectFieldTime },
            { no: 9, name: "geopoint_value", kind: "message", oneof: "value", T: () => ObjectFieldGeopoint },
            { no: 10, name: "blob_value", kind: "message", oneof: "value", T: () => ObjectFieldBlob },
            { no: 12, name: "blockchain_addr_value", kind: "message", oneof: "value", T: () => ObjectFieldBlockchainAddress },
            { no: 13, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<ObjectField>): ObjectField {
        const message = { label: "", type: 0, did: "", value: { oneofKind: undefined }, metadata: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ObjectField>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ObjectField): ObjectField {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* sonrio.sonr.object.ObjectFieldType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* string did */ 3:
                    message.did = reader.string();
                    break;
                case /* sonrio.sonr.object.ObjectFieldText string_value */ 4:
                    message.value = {
                        oneofKind: "stringValue",
                        stringValue: ObjectFieldText.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).stringValue)
                    };
                    break;
                case /* sonrio.sonr.object.ObjectFieldNumber number_value */ 5:
                    message.value = {
                        oneofKind: "numberValue",
                        numberValue: ObjectFieldNumber.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).numberValue)
                    };
                    break;
                case /* sonrio.sonr.object.ObjectFieldBool bool_value */ 6:
                    message.value = {
                        oneofKind: "boolValue",
                        boolValue: ObjectFieldBool.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).boolValue)
                    };
                    break;
                case /* sonrio.sonr.object.ObjectFieldArray array_value */ 7:
                    message.value = {
                        oneofKind: "arrayValue",
                        arrayValue: ObjectFieldArray.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).arrayValue)
                    };
                    break;
                case /* sonrio.sonr.object.ObjectFieldTime time_stamp_value */ 8:
                    message.value = {
                        oneofKind: "timeStampValue",
                        timeStampValue: ObjectFieldTime.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).timeStampValue)
                    };
                    break;
                case /* sonrio.sonr.object.ObjectFieldGeopoint geopoint_value */ 9:
                    message.value = {
                        oneofKind: "geopointValue",
                        geopointValue: ObjectFieldGeopoint.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).geopointValue)
                    };
                    break;
                case /* sonrio.sonr.object.ObjectFieldBlob blob_value */ 10:
                    message.value = {
                        oneofKind: "blobValue",
                        blobValue: ObjectFieldBlob.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).blobValue)
                    };
                    break;
                case /* sonrio.sonr.object.ObjectFieldBlockchainAddress blockchain_addr_value */ 12:
                    message.value = {
                        oneofKind: "blockchainAddrValue",
                        blockchainAddrValue: ObjectFieldBlockchainAddress.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).blockchainAddrValue)
                    };
                    break;
                case /* map<string, string> metadata */ 13:
                    this.binaryReadMap13(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap13(map: ObjectField["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ObjectField["metadata"] | undefined, val: ObjectField["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field sonrio.sonr.object.ObjectField.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: ObjectField, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* sonrio.sonr.object.ObjectFieldType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* string did = 3; */
        if (message.did !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.did);
        /* sonrio.sonr.object.ObjectFieldText string_value = 4; */
        if (message.value.oneofKind === "stringValue")
            ObjectFieldText.internalBinaryWrite(message.value.stringValue, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* sonrio.sonr.object.ObjectFieldNumber number_value = 5; */
        if (message.value.oneofKind === "numberValue")
            ObjectFieldNumber.internalBinaryWrite(message.value.numberValue, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* sonrio.sonr.object.ObjectFieldBool bool_value = 6; */
        if (message.value.oneofKind === "boolValue")
            ObjectFieldBool.internalBinaryWrite(message.value.boolValue, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* sonrio.sonr.object.ObjectFieldArray array_value = 7; */
        if (message.value.oneofKind === "arrayValue")
            ObjectFieldArray.internalBinaryWrite(message.value.arrayValue, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* sonrio.sonr.object.ObjectFieldTime time_stamp_value = 8; */
        if (message.value.oneofKind === "timeStampValue")
            ObjectFieldTime.internalBinaryWrite(message.value.timeStampValue, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* sonrio.sonr.object.ObjectFieldGeopoint geopoint_value = 9; */
        if (message.value.oneofKind === "geopointValue")
            ObjectFieldGeopoint.internalBinaryWrite(message.value.geopointValue, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* sonrio.sonr.object.ObjectFieldBlob blob_value = 10; */
        if (message.value.oneofKind === "blobValue")
            ObjectFieldBlob.internalBinaryWrite(message.value.blobValue, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* sonrio.sonr.object.ObjectFieldBlockchainAddress blockchain_addr_value = 12; */
        if (message.value.oneofKind === "blockchainAddrValue")
            ObjectFieldBlockchainAddress.internalBinaryWrite(message.value.blockchainAddrValue, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* map<string, string> metadata = 13; */
        for (let k of Object.keys(message.metadata))
            writer.tag(13, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.object.ObjectField
 */
export const ObjectField = new ObjectField$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectFieldArray$Type extends MessageType<ObjectFieldArray> {
    constructor() {
        super("sonrio.sonr.object.ObjectFieldArray", [
            { no: 1, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["sonrio.sonr.object.ObjectFieldType", ObjectFieldType, "OBJECT_FIELD_TYPE_"] },
            { no: 3, name: "did", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ObjectField }
        ]);
    }
    create(value?: PartialMessage<ObjectFieldArray>): ObjectFieldArray {
        const message = { label: "", type: 0, did: "", items: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ObjectFieldArray>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ObjectFieldArray): ObjectFieldArray {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* sonrio.sonr.object.ObjectFieldType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* string did */ 3:
                    message.did = reader.string();
                    break;
                case /* repeated sonrio.sonr.object.ObjectField items */ 4:
                    message.items.push(ObjectField.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ObjectFieldArray, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* sonrio.sonr.object.ObjectFieldType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* string did = 3; */
        if (message.did !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.did);
        /* repeated sonrio.sonr.object.ObjectField items = 4; */
        for (let i = 0; i < message.items.length; i++)
            ObjectField.internalBinaryWrite(message.items[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.object.ObjectFieldArray
 */
export const ObjectFieldArray = new ObjectFieldArray$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectFieldText$Type extends MessageType<ObjectFieldText> {
    constructor() {
        super("sonrio.sonr.object.ObjectFieldText", [
            { no: 1, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "did", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<ObjectFieldText>): ObjectFieldText {
        const message = { label: "", did: "", value: "", metadata: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ObjectFieldText>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ObjectFieldText): ObjectFieldText {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* string did */ 2:
                    message.did = reader.string();
                    break;
                case /* string value */ 3:
                    message.value = reader.string();
                    break;
                case /* map<string, string> metadata */ 4:
                    this.binaryReadMap4(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: ObjectFieldText["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ObjectFieldText["metadata"] | undefined, val: ObjectFieldText["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field sonrio.sonr.object.ObjectFieldText.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: ObjectFieldText, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* string did = 2; */
        if (message.did !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.did);
        /* string value = 3; */
        if (message.value !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.value);
        /* map<string, string> metadata = 4; */
        for (let k of Object.keys(message.metadata))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.object.ObjectFieldText
 */
export const ObjectFieldText = new ObjectFieldText$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectFieldNumber$Type extends MessageType<ObjectFieldNumber> {
    constructor() {
        super("sonrio.sonr.object.ObjectFieldNumber", [
            { no: 1, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "did", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<ObjectFieldNumber>): ObjectFieldNumber {
        const message = { label: "", did: "", value: 0, metadata: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ObjectFieldNumber>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ObjectFieldNumber): ObjectFieldNumber {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* string did */ 2:
                    message.did = reader.string();
                    break;
                case /* double value */ 3:
                    message.value = reader.double();
                    break;
                case /* map<string, string> metadata */ 4:
                    this.binaryReadMap4(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: ObjectFieldNumber["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ObjectFieldNumber["metadata"] | undefined, val: ObjectFieldNumber["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field sonrio.sonr.object.ObjectFieldNumber.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: ObjectFieldNumber, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* string did = 2; */
        if (message.did !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.did);
        /* double value = 3; */
        if (message.value !== 0)
            writer.tag(3, WireType.Bit64).double(message.value);
        /* map<string, string> metadata = 4; */
        for (let k of Object.keys(message.metadata))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.object.ObjectFieldNumber
 */
export const ObjectFieldNumber = new ObjectFieldNumber$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectFieldBool$Type extends MessageType<ObjectFieldBool> {
    constructor() {
        super("sonrio.sonr.object.ObjectFieldBool", [
            { no: 1, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "did", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<ObjectFieldBool>): ObjectFieldBool {
        const message = { label: "", did: "", value: false, metadata: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ObjectFieldBool>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ObjectFieldBool): ObjectFieldBool {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* string did */ 2:
                    message.did = reader.string();
                    break;
                case /* bool value */ 3:
                    message.value = reader.bool();
                    break;
                case /* map<string, string> metadata */ 4:
                    this.binaryReadMap4(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: ObjectFieldBool["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ObjectFieldBool["metadata"] | undefined, val: ObjectFieldBool["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field sonrio.sonr.object.ObjectFieldBool.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: ObjectFieldBool, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* string did = 2; */
        if (message.did !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.did);
        /* bool value = 3; */
        if (message.value !== false)
            writer.tag(3, WireType.Varint).bool(message.value);
        /* map<string, string> metadata = 4; */
        for (let k of Object.keys(message.metadata))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.object.ObjectFieldBool
 */
export const ObjectFieldBool = new ObjectFieldBool$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectFieldTime$Type extends MessageType<ObjectFieldTime> {
    constructor() {
        super("sonrio.sonr.object.ObjectFieldTime", [
            { no: 1, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "did", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "value", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 4, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<ObjectFieldTime>): ObjectFieldTime {
        const message = { label: "", did: "", value: "0", metadata: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ObjectFieldTime>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ObjectFieldTime): ObjectFieldTime {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* string did */ 2:
                    message.did = reader.string();
                    break;
                case /* int64 value */ 3:
                    message.value = reader.int64().toString();
                    break;
                case /* map<string, string> metadata */ 4:
                    this.binaryReadMap4(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: ObjectFieldTime["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ObjectFieldTime["metadata"] | undefined, val: ObjectFieldTime["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field sonrio.sonr.object.ObjectFieldTime.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: ObjectFieldTime, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* string did = 2; */
        if (message.did !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.did);
        /* int64 value = 3; */
        if (message.value !== "0")
            writer.tag(3, WireType.Varint).int64(message.value);
        /* map<string, string> metadata = 4; */
        for (let k of Object.keys(message.metadata))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.object.ObjectFieldTime
 */
export const ObjectFieldTime = new ObjectFieldTime$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectFieldGeopoint$Type extends MessageType<ObjectFieldGeopoint> {
    constructor() {
        super("sonrio.sonr.object.ObjectFieldGeopoint", [
            { no: 1, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["sonrio.sonr.object.ObjectFieldType", ObjectFieldType, "OBJECT_FIELD_TYPE_"] },
            { no: 3, name: "did", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "latitude", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "longitude", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<ObjectFieldGeopoint>): ObjectFieldGeopoint {
        const message = { label: "", type: 0, did: "", latitude: 0, longitude: 0, metadata: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ObjectFieldGeopoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ObjectFieldGeopoint): ObjectFieldGeopoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* sonrio.sonr.object.ObjectFieldType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* string did */ 3:
                    message.did = reader.string();
                    break;
                case /* double latitude */ 4:
                    message.latitude = reader.double();
                    break;
                case /* double longitude */ 5:
                    message.longitude = reader.double();
                    break;
                case /* map<string, string> metadata */ 6:
                    this.binaryReadMap6(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap6(map: ObjectFieldGeopoint["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ObjectFieldGeopoint["metadata"] | undefined, val: ObjectFieldGeopoint["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field sonrio.sonr.object.ObjectFieldGeopoint.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: ObjectFieldGeopoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* sonrio.sonr.object.ObjectFieldType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* string did = 3; */
        if (message.did !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.did);
        /* double latitude = 4; */
        if (message.latitude !== 0)
            writer.tag(4, WireType.Bit64).double(message.latitude);
        /* double longitude = 5; */
        if (message.longitude !== 0)
            writer.tag(5, WireType.Bit64).double(message.longitude);
        /* map<string, string> metadata = 6; */
        for (let k of Object.keys(message.metadata))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.object.ObjectFieldGeopoint
 */
export const ObjectFieldGeopoint = new ObjectFieldGeopoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectFieldBlob$Type extends MessageType<ObjectFieldBlob> {
    constructor() {
        super("sonrio.sonr.object.ObjectFieldBlob", [
            { no: 1, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "did", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<ObjectFieldBlob>): ObjectFieldBlob {
        const message = { label: "", did: "", value: new Uint8Array(0), metadata: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ObjectFieldBlob>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ObjectFieldBlob): ObjectFieldBlob {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* string did */ 2:
                    message.did = reader.string();
                    break;
                case /* bytes value */ 3:
                    message.value = reader.bytes();
                    break;
                case /* map<string, string> metadata */ 4:
                    this.binaryReadMap4(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: ObjectFieldBlob["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ObjectFieldBlob["metadata"] | undefined, val: ObjectFieldBlob["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field sonrio.sonr.object.ObjectFieldBlob.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: ObjectFieldBlob, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* string did = 2; */
        if (message.did !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.did);
        /* bytes value = 3; */
        if (message.value.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.value);
        /* map<string, string> metadata = 4; */
        for (let k of Object.keys(message.metadata))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.object.ObjectFieldBlob
 */
export const ObjectFieldBlob = new ObjectFieldBlob$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectFieldBlockchainAddress$Type extends MessageType<ObjectFieldBlockchainAddress> {
    constructor() {
        super("sonrio.sonr.object.ObjectFieldBlockchainAddress", [
            { no: 1, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "did", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<ObjectFieldBlockchainAddress>): ObjectFieldBlockchainAddress {
        const message = { label: "", did: "", value: "", metadata: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ObjectFieldBlockchainAddress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ObjectFieldBlockchainAddress): ObjectFieldBlockchainAddress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* string did */ 2:
                    message.did = reader.string();
                    break;
                case /* string value */ 3:
                    message.value = reader.string();
                    break;
                case /* map<string, string> metadata */ 4:
                    this.binaryReadMap4(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: ObjectFieldBlockchainAddress["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ObjectFieldBlockchainAddress["metadata"] | undefined, val: ObjectFieldBlockchainAddress["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field sonrio.sonr.object.ObjectFieldBlockchainAddress.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: ObjectFieldBlockchainAddress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* string did = 2; */
        if (message.did !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.did);
        /* string value = 3; */
        if (message.value !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.value);
        /* map<string, string> metadata = 4; */
        for (let k of Object.keys(message.metadata))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.object.ObjectFieldBlockchainAddress
 */
export const ObjectFieldBlockchainAddress = new ObjectFieldBlockchainAddress$Type();
