// @generated by protobuf-ts 2.2.1 with parameter long_type_string,generate_dependencies
// @generated from protobuf file "registry/did.proto" (package "sonrio.sonr.registry", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Did represents a string that has been parsed and validated as a DID. The parts are stored
 * in the individual fields.
 *
 * @generated from protobuf message sonrio.sonr.registry.Did
 */
export interface Did {
    /**
     * Method is the method used to create the DID. For the Sonr network it is "sonr".
     *
     * @generated from protobuf field: string method = 1;
     */
    method: string;
    /**
     * Network is the network the DID is on. For testnet it is "testnet". i.e "did:sonr:testnet:".
     *
     * @generated from protobuf field: string network = 2;
     */
    network: string;
    /**
     * id is the trailing identifier after the network. i.e. "did:sonr:testnet:abc123"
     *
     * @generated from protobuf field: string id = 3;
     */
    id: string;
    /**
     * Paths is a list of paths that the DID is valid for. This is used to identify the Service.
     *
     * @generated from protobuf field: repeated string paths = 4;
     */
    paths: string[];
    /**
     * Query is the query string that was used to create the DID. This is followed by a '?'.
     *
     * @generated from protobuf field: string query = 5;
     */
    query: string;
    /**
     * Fragment is the fragment string that was used to create the DID. This is followed by a '#'.
     *
     * @generated from protobuf field: string fragment = 6;
     */
    fragment: string;
}
/**
 * DidDocument is the document that describes a DID. This document is stored on the blockchain.
 *
 * @generated from protobuf message sonrio.sonr.registry.DidDocument
 */
export interface DidDocument {
    /**
     * Context is the context of the DID document. This is used to identify the Service.
     *
     * @generated from protobuf field: repeated string context = 1;
     */
    context: string[]; // optional
    /**
     * Id is the DID of the document.
     *
     * @generated from protobuf field: string id = 2;
     */
    id: string;
    /**
     * Controller is the DID of the controller of the document. This will be the individual user devices and mailboxes.
     *
     * @generated from protobuf field: repeated string controller = 3;
     */
    controller: string[]; // optional
    /**
     * VerificationMethod is the list of verification methods for the user.
     *
     * @generated from protobuf field: repeated sonrio.sonr.registry.VerificationMethod verification_method = 4;
     */
    verificationMethod: VerificationMethod[]; // optional
    /**
     * Authentication is the list of authentication methods for the user.
     *
     * @generated from protobuf field: repeated string authentication = 5;
     */
    authentication: string[]; // optional
    /**
     * AssertionMethod is the list of assertion methods for the user.
     *
     * @generated from protobuf field: repeated string assertion_method = 6;
     */
    assertionMethod: string[]; // optional
    /**
     * CapabilityInvocation is the list of capability invocation methods for the user.
     *
     * @generated from protobuf field: repeated string capability_invocation = 7;
     */
    capabilityInvocation: string[]; // optional
    /**
     * CapabilityDelegation is the list of capability delegation methods for the user.
     *
     * @generated from protobuf field: repeated string capability_delegation = 8;
     */
    capabilityDelegation: string[]; // optional
    /**
     * KeyAgreement is the list of key agreement methods for the user.
     *
     * @generated from protobuf field: repeated string key_agreement = 9;
     */
    keyAgreement: string[]; // optional
    /**
     * Service is the list of services or DApps that the user has access to.
     *
     * @generated from protobuf field: repeated sonrio.sonr.registry.Service service = 10;
     */
    service: Service[]; // optional
    /**
     * AlsoKnownAs is the list of ".snr" aliases for the user.
     *
     * @generated from protobuf field: repeated string also_known_as = 11;
     */
    alsoKnownAs: string[]; // optional
    /**
     * Metadata is the metadata of the service.
     *
     * @generated from protobuf field: map<string, string> metadata = 12;
     */
    metadata: {
        [key: string]: string;
    }; // optional
}
/**
 * Service is a Application that runs on the Sonr network.
 *
 * @generated from protobuf message sonrio.sonr.registry.Service
 */
export interface Service {
    /**
     * ID is the DID of the service.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * Type is the type of the service.
     *
     * @generated from protobuf field: sonrio.sonr.registry.ServiceType type = 2;
     */
    type: ServiceType;
    /**
     * ServiceEndpoint is the endpoint of the service.
     *
     * @generated from protobuf field: sonrio.sonr.registry.ServiceEndpoint service_endpoint = 3;
     */
    serviceEndpoint?: ServiceEndpoint;
    /**
     * Metadata is the metadata of the service.
     *
     * @generated from protobuf field: map<string, string> metadata = 4;
     */
    metadata: {
        [key: string]: string;
    }; // optional
}
/**
 * ServiceEndpoint is the endpoint of the service.
 *
 * @generated from protobuf message sonrio.sonr.registry.ServiceEndpoint
 */
export interface ServiceEndpoint {
    /**
     * TransportType is the type of transport used to connect to the service.
     *
     * @generated from protobuf field: string transport_type = 1;
     */
    transportType: string;
    /**
     * Network is the network the service is on.
     *
     * @generated from protobuf field: string network = 2;
     */
    network: string;
    /**
     * SupportedProtocols is the list of protocols supported by the service.
     * (e.g. "channels", "buckets", "objects", "storage")
     *
     * @generated from protobuf field: repeated sonrio.sonr.registry.ServiceProtocol supported_protocols = 3;
     */
    supportedProtocols: ServiceProtocol[];
}
/**
 * VerificationMethod is a method that can be used to verify the DID.
 *
 * @generated from protobuf message sonrio.sonr.registry.VerificationMethod
 */
export interface VerificationMethod {
    /**
     * ID is the DID of the verification method.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * Type is the type of the verification method.
     *
     * @generated from protobuf field: sonrio.sonr.registry.VerificationMethod.Type type = 2;
     */
    type: VerificationMethod_Type;
    /**
     * Controller is the DID of the controller of the verification method.
     *
     * @generated from protobuf field: string controller = 3;
     */
    controller: string;
    /**
     * PublicKeyHex is the public key of the verification method in hexidecimal.
     *
     * @generated from protobuf field: string public_key_hex = 4;
     */
    publicKeyHex: string; // optional
    /**
     * PublicKeyBase58 is the public key of the verification method in base58.
     *
     * @generated from protobuf field: string public_key_base58 = 5;
     */
    publicKeyBase58: string; // optional
    /**
     * BlockchainAccountId is the blockchain account id of the verification method.
     *
     * @generated from protobuf field: string blockchain_account_id = 6;
     */
    blockchainAccountId: string; // optional
}
/**
 * @generated from protobuf enum sonrio.sonr.registry.VerificationMethod.Type
 */
export enum VerificationMethod_Type {
    /**
     * TYPE_UNSPECIFIED is the default value.
     *
     * @generated from protobuf enum value: TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * TYPE_ECDSA_SECP256K1 represents the Ed25519VerificationKey2018 key type.
     *
     * @generated from protobuf enum value: TYPE_ECDSA_SECP256K1 = 1;
     */
    ECDSA_SECP256K1 = 1,
    /**
     * TYPE_X25519 represents the X25519KeyAgreementKey2019 key type.
     *
     * @generated from protobuf enum value: TYPE_X25519 = 2;
     */
    X25519 = 2,
    /**
     * TYPE_ED25519 represents the Ed25519VerificationKey2018 key type.
     *
     * @generated from protobuf enum value: TYPE_ED25519 = 3;
     */
    ED25519 = 3,
    /**
     * TYPE_BLS_12381_G1 represents the Bls12381G1Key2020 key type
     *
     * @generated from protobuf enum value: TYPE_BLS_12381_G1 = 4;
     */
    BLS_12381_G1 = 4,
    /**
     * TYPE_BLS_12381_G2 represents the Bls12381G2Key2020 key type
     *
     * @generated from protobuf enum value: TYPE_BLS_12381_G2 = 5;
     */
    BLS_12381_G2 = 5,
    /**
     * TYPE_RSA represents the RsaVerificationKey2018 key type.
     *
     * @generated from protobuf enum value: TYPE_RSA = 6;
     */
    RSA = 6,
    /**
     * TYPE_VERIFIABLE_CONDITION represents the VerifiableCondition2021 key type.
     *
     * @generated from protobuf enum value: TYPE_VERIFIABLE_CONDITION = 7;
     */
    VERIFIABLE_CONDITION = 7
}
/**
 * NetworkType is the type of network the DID is on.
 *
 * @generated from protobuf enum sonrio.sonr.registry.NetworkType
 */
export enum NetworkType {
    /**
     * Unspecified is the default value. Gets converted to "did:sonr:".
     *
     * @generated from protobuf enum value: NETWORK_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Mainnet is the main network. It prefix is "did:sonr:" or "did:sonr:mainnet:".
     *
     * @generated from protobuf enum value: NETWORK_TYPE_MAINNET = 1;
     */
    MAINNET = 1,
    /**
     * Testnet is the deployed test network. It's prefix is "did:sonr:testnet:".
     *
     * @generated from protobuf enum value: NETWORK_TYPE_TESTNET = 2;
     */
    TESTNET = 2,
    /**
     * Devnet is the localhost test network. It's prefix is "did:sonr:devnet:".
     *
     * @generated from protobuf enum value: NETWORK_TYPE_DEVNET = 3;
     */
    DEVNET = 3
}
/**
 * ServiceProtocol are core modules that can be installed on custom services on the Sonr network.
 *
 * @generated from protobuf enum sonrio.sonr.registry.ServiceProtocol
 */
export enum ServiceProtocol {
    /**
     * SERVICE_PROTOCOL_UNSPECIFIED is the default value.
     *
     * @generated from protobuf enum value: SERVICE_PROTOCOL_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * SERVICE_PROTOCOL_BUCKETS is the module that provides the ability to store and retrieve data.
     *
     * @generated from protobuf enum value: SERVICE_PROTOCOL_BUCKETS = 1;
     */
    BUCKETS = 1,
    /**
     * SERVICE_PROTOCOL_CHANNEL is the module that provides the ability to communicate with other services.
     *
     * @generated from protobuf enum value: SERVICE_PROTOCOL_CHANNEL = 2;
     */
    CHANNEL = 2,
    /**
     * SERVICE_PROTOCOL_OBJECTS is the module that provides the ability to create new schemas for data on the network.
     *
     * @generated from protobuf enum value: SERVICE_PROTOCOL_OBJECTS = 3;
     */
    OBJECTS = 3,
    /**
     * SERVICE_PROTOCOL_FUNCTIONS is the module that provides the ability to create new functions for data on the network.
     *
     * @generated from protobuf enum value: SERVICE_PROTOCOL_FUNCTIONS = 4;
     */
    FUNCTIONS = 4
}
/**
 * ServiceType is the type of service that is being registered.
 *
 * @generated from protobuf enum sonrio.sonr.registry.ServiceType
 */
export enum ServiceType {
    /**
     * SERVICE_TYPE_UNSPECIFIED is the default value.
     *
     * @generated from protobuf enum value: SERVICE_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * SERVICE_TYPE_APPLICATION is the type of service that is a DApp.
     *
     * @generated from protobuf enum value: SERVICE_TYPE_DID_COMM_MESSAGING = 1;
     */
    DID_COMM_MESSAGING = 1,
    /**
     * SERVICE_TYPE_SERVICE is the type of service that is a service.
     *
     * @generated from protobuf enum value: SERVICE_TYPE_LINKED_DOMAINS = 2;
     */
    LINKED_DOMAINS = 2,
    /**
     * SERVICE_TYPE_SONR is the type of service that is a DApp.
     *
     * @generated from protobuf enum value: SERVICE_TYPE_SONR = 3;
     */
    SONR = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class Did$Type extends MessageType<Did> {
    constructor() {
        super("sonrio.sonr.registry.Did", [
            { no: 1, name: "method", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "network", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "paths", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "fragment", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Did>): Did {
        const message = { method: "", network: "", id: "", paths: [], query: "", fragment: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Did>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Did): Did {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string method */ 1:
                    message.method = reader.string();
                    break;
                case /* string network */ 2:
                    message.network = reader.string();
                    break;
                case /* string id */ 3:
                    message.id = reader.string();
                    break;
                case /* repeated string paths */ 4:
                    message.paths.push(reader.string());
                    break;
                case /* string query */ 5:
                    message.query = reader.string();
                    break;
                case /* string fragment */ 6:
                    message.fragment = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Did, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string method = 1; */
        if (message.method !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.method);
        /* string network = 2; */
        if (message.network !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.network);
        /* string id = 3; */
        if (message.id !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.id);
        /* repeated string paths = 4; */
        for (let i = 0; i < message.paths.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.paths[i]);
        /* string query = 5; */
        if (message.query !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.query);
        /* string fragment = 6; */
        if (message.fragment !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.fragment);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.registry.Did
 */
export const Did = new Did$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DidDocument$Type extends MessageType<DidDocument> {
    constructor() {
        super("sonrio.sonr.registry.DidDocument", [
            { no: 1, name: "context", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "controller", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "verification_method", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => VerificationMethod },
            { no: 5, name: "authentication", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "assertion_method", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "capability_invocation", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "capability_delegation", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "key_agreement", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "service", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Service },
            { no: 11, name: "also_known_as", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<DidDocument>): DidDocument {
        const message = { context: [], id: "", controller: [], verificationMethod: [], authentication: [], assertionMethod: [], capabilityInvocation: [], capabilityDelegation: [], keyAgreement: [], service: [], alsoKnownAs: [], metadata: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DidDocument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DidDocument): DidDocument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string context */ 1:
                    message.context.push(reader.string());
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* repeated string controller */ 3:
                    message.controller.push(reader.string());
                    break;
                case /* repeated sonrio.sonr.registry.VerificationMethod verification_method */ 4:
                    message.verificationMethod.push(VerificationMethod.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string authentication */ 5:
                    message.authentication.push(reader.string());
                    break;
                case /* repeated string assertion_method */ 6:
                    message.assertionMethod.push(reader.string());
                    break;
                case /* repeated string capability_invocation */ 7:
                    message.capabilityInvocation.push(reader.string());
                    break;
                case /* repeated string capability_delegation */ 8:
                    message.capabilityDelegation.push(reader.string());
                    break;
                case /* repeated string key_agreement */ 9:
                    message.keyAgreement.push(reader.string());
                    break;
                case /* repeated sonrio.sonr.registry.Service service */ 10:
                    message.service.push(Service.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string also_known_as */ 11:
                    message.alsoKnownAs.push(reader.string());
                    break;
                case /* map<string, string> metadata */ 12:
                    this.binaryReadMap12(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap12(map: DidDocument["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DidDocument["metadata"] | undefined, val: DidDocument["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field sonrio.sonr.registry.DidDocument.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: DidDocument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string context = 1; */
        for (let i = 0; i < message.context.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.context[i]);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* repeated string controller = 3; */
        for (let i = 0; i < message.controller.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.controller[i]);
        /* repeated sonrio.sonr.registry.VerificationMethod verification_method = 4; */
        for (let i = 0; i < message.verificationMethod.length; i++)
            VerificationMethod.internalBinaryWrite(message.verificationMethod[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated string authentication = 5; */
        for (let i = 0; i < message.authentication.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.authentication[i]);
        /* repeated string assertion_method = 6; */
        for (let i = 0; i < message.assertionMethod.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.assertionMethod[i]);
        /* repeated string capability_invocation = 7; */
        for (let i = 0; i < message.capabilityInvocation.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.capabilityInvocation[i]);
        /* repeated string capability_delegation = 8; */
        for (let i = 0; i < message.capabilityDelegation.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.capabilityDelegation[i]);
        /* repeated string key_agreement = 9; */
        for (let i = 0; i < message.keyAgreement.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.keyAgreement[i]);
        /* repeated sonrio.sonr.registry.Service service = 10; */
        for (let i = 0; i < message.service.length; i++)
            Service.internalBinaryWrite(message.service[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated string also_known_as = 11; */
        for (let i = 0; i < message.alsoKnownAs.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.alsoKnownAs[i]);
        /* map<string, string> metadata = 12; */
        for (let k of Object.keys(message.metadata))
            writer.tag(12, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.registry.DidDocument
 */
export const DidDocument = new DidDocument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Service$Type extends MessageType<Service> {
    constructor() {
        super("sonrio.sonr.registry.Service", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["sonrio.sonr.registry.ServiceType", ServiceType, "SERVICE_TYPE_"] },
            { no: 3, name: "service_endpoint", kind: "message", T: () => ServiceEndpoint },
            { no: 4, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<Service>): Service {
        const message = { id: "", type: 0, metadata: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Service>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Service): Service {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* sonrio.sonr.registry.ServiceType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* sonrio.sonr.registry.ServiceEndpoint service_endpoint */ 3:
                    message.serviceEndpoint = ServiceEndpoint.internalBinaryRead(reader, reader.uint32(), options, message.serviceEndpoint);
                    break;
                case /* map<string, string> metadata */ 4:
                    this.binaryReadMap4(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: Service["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Service["metadata"] | undefined, val: Service["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field sonrio.sonr.registry.Service.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Service, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* sonrio.sonr.registry.ServiceType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* sonrio.sonr.registry.ServiceEndpoint service_endpoint = 3; */
        if (message.serviceEndpoint)
            ServiceEndpoint.internalBinaryWrite(message.serviceEndpoint, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* map<string, string> metadata = 4; */
        for (let k of Object.keys(message.metadata))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.registry.Service
 */
export const Service = new Service$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceEndpoint$Type extends MessageType<ServiceEndpoint> {
    constructor() {
        super("sonrio.sonr.registry.ServiceEndpoint", [
            { no: 1, name: "transport_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "network", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "supported_protocols", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["sonrio.sonr.registry.ServiceProtocol", ServiceProtocol, "SERVICE_PROTOCOL_"] }
        ]);
    }
    create(value?: PartialMessage<ServiceEndpoint>): ServiceEndpoint {
        const message = { transportType: "", network: "", supportedProtocols: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServiceEndpoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceEndpoint): ServiceEndpoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string transport_type */ 1:
                    message.transportType = reader.string();
                    break;
                case /* string network */ 2:
                    message.network = reader.string();
                    break;
                case /* repeated sonrio.sonr.registry.ServiceProtocol supported_protocols */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.supportedProtocols.push(reader.int32());
                    else
                        message.supportedProtocols.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceEndpoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string transport_type = 1; */
        if (message.transportType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.transportType);
        /* string network = 2; */
        if (message.network !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.network);
        /* repeated sonrio.sonr.registry.ServiceProtocol supported_protocols = 3; */
        if (message.supportedProtocols.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.supportedProtocols.length; i++)
                writer.int32(message.supportedProtocols[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.registry.ServiceEndpoint
 */
export const ServiceEndpoint = new ServiceEndpoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VerificationMethod$Type extends MessageType<VerificationMethod> {
    constructor() {
        super("sonrio.sonr.registry.VerificationMethod", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["sonrio.sonr.registry.VerificationMethod.Type", VerificationMethod_Type, "TYPE_"] },
            { no: 3, name: "controller", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "public_key_hex", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "public_key_base58", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "blockchain_account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VerificationMethod>): VerificationMethod {
        const message = { id: "", type: 0, controller: "", publicKeyHex: "", publicKeyBase58: "", blockchainAccountId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VerificationMethod>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VerificationMethod): VerificationMethod {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* sonrio.sonr.registry.VerificationMethod.Type type */ 2:
                    message.type = reader.int32();
                    break;
                case /* string controller */ 3:
                    message.controller = reader.string();
                    break;
                case /* string public_key_hex */ 4:
                    message.publicKeyHex = reader.string();
                    break;
                case /* string public_key_base58 */ 5:
                    message.publicKeyBase58 = reader.string();
                    break;
                case /* string blockchain_account_id */ 6:
                    message.blockchainAccountId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VerificationMethod, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* sonrio.sonr.registry.VerificationMethod.Type type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* string controller = 3; */
        if (message.controller !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.controller);
        /* string public_key_hex = 4; */
        if (message.publicKeyHex !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.publicKeyHex);
        /* string public_key_base58 = 5; */
        if (message.publicKeyBase58 !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.publicKeyBase58);
        /* string blockchain_account_id = 6; */
        if (message.blockchainAccountId !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.blockchainAccountId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.registry.VerificationMethod
 */
export const VerificationMethod = new VerificationMethod$Type();
