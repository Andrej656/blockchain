// @generated by protobuf-ts 2.2.1 with parameter long_type_string,generate_dependencies
// @generated from protobuf file "registry/peer.proto" (package "sonrio.sonr.registry", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Location from GeoIP and OLC information
 *
 * @generated from protobuf message sonrio.sonr.registry.Location
 */
export interface Location {
    /**
     * Location Latitude
     *
     * @generated from protobuf field: double latitude = 1;
     */
    latitude: number;
    /**
     * Location Longitude
     *
     * @generated from protobuf field: double longitude = 2;
     */
    longitude: number;
    /**
     * Location Placemark Information - Generated
     *
     * @generated from protobuf field: sonrio.sonr.registry.Location.Placemark placemark = 3;
     */
    placemark?: Location_Placemark;
    /**
     * Last Updated Time
     *
     * @generated from protobuf field: int64 last_modified = 4;
     */
    lastModified: string;
}
/**
 * Contains detailed placemark information.
 *
 * @generated from protobuf message sonrio.sonr.registry.Location.Placemark
 */
export interface Location_Placemark {
    /**
     * The name associated with the placemark.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The street associated with the placemark.
     *
     * @generated from protobuf field: string street = 2;
     */
    street: string;
    /**
     * The abbreviated country name, according to the two letter (alpha-2) [ISO
     * standard](https://www.iso.org/iso-3166-country-codes.html).
     *
     * @generated from protobuf field: string iso_country_code = 3;
     */
    isoCountryCode: string;
    /**
     * The name of the country associated with the placemark.
     *
     * @generated from protobuf field: string country = 4;
     */
    country: string;
    /**
     * The postal code associated with the placemark.
     *
     * @generated from protobuf field: string postal_code = 5;
     */
    postalCode: string;
    /**
     * The name of the state or province associated with the placemark.
     *
     * @generated from protobuf field: string administrative_area = 6;
     */
    administrativeArea: string;
    /**
     * Additional administrative area information for the placemark.
     *
     * @generated from protobuf field: string sub_administrative_area = 7;
     */
    subAdministrativeArea: string;
    /**
     * The name of the city associated with the placemark.
     *
     * @generated from protobuf field: string locality = 8;
     */
    locality: string;
    /**
     * Additional city-level information for the placemark.
     *
     * @generated from protobuf field: string sub_locality = 9;
     */
    subLocality: string;
    /**
     * The street address associated with the placemark.
     *
     * @generated from protobuf field: string thoroughfare = 10;
     */
    thoroughfare: string;
    /**
     * Additional street address information for the placemark.
     *
     * @generated from protobuf field: string sub_thoroughfare = 11;
     */
    subThoroughfare: string;
}
/**
 * Shared Metadata for Messages on all Protocols
 *
 * @generated from protobuf message sonrio.sonr.registry.Metadata
 */
export interface Metadata {
    /**
     * Unix timestamp
     *
     * @generated from protobuf field: int64 timestamp = 1;
     */
    timestamp: string;
    /**
     * Node ID
     *
     * @generated from protobuf field: string node_id = 2;
     */
    nodeId: string;
    /**
     * Signature of the message
     *
     * @generated from protobuf field: bytes signature = 3;
     */
    signature: Uint8Array;
    /**
     * Public Key of the message sender
     *
     * @generated from protobuf field: bytes public_key = 4;
     */
    publicKey: Uint8Array;
}
/**
 * Basic Info Sent to Peers to Establish Connections
 *
 * @generated from protobuf message sonrio.sonr.registry.Peer
 */
export interface Peer {
    /**
     * @generated from protobuf field: string s_name = 1;
     */
    sName: string; // User Sonr Domain
    /**
     * @generated from protobuf field: sonrio.sonr.registry.Peer.Status status = 2;
     */
    status: Peer_Status; // Peer Status
    /**
     * @generated from protobuf field: sonrio.sonr.registry.Peer.Device device = 3;
     */
    device?: Peer_Device; // Peer Device Info
    /**
     * @generated from protobuf field: sonrio.sonr.registry.Profile profile = 4;
     */
    profile?: Profile; // Peers General Information
    /**
     * @generated from protobuf field: bytes public_key = 5;
     */
    publicKey: Uint8Array; // Public Key of the Peer
    /**
     * @generated from protobuf field: string peer_id = 6;
     */
    peerId: string; // Peer ID
    /**
     * @generated from protobuf field: int64 last_modified = 7;
     */
    lastModified: string; // Last Modified Timestamp
}
/**
 * Peer Info for Device
 *
 * @generated from protobuf message sonrio.sonr.registry.Peer.Device
 */
export interface Peer_Device {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string; // Peer Device ID
    /**
     * @generated from protobuf field: string host_name = 2;
     */
    hostName: string; // Peer Host Name
    /**
     * @generated from protobuf field: string os = 3;
     */
    os: string; // Peer Operating System
    /**
     * @generated from protobuf field: string arch = 4;
     */
    arch: string; // Peer Architecture
    /**
     * @generated from protobuf field: string model = 5;
     */
    model: string; // Peers Device Model
}
/**
 * Peers Active Status
 *
 * @generated from protobuf enum sonrio.sonr.registry.Peer.Status
 */
export enum Peer_Status {
    /**
     * Offline - Not Online or Not a Full Node
     *
     * @generated from protobuf enum value: STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Online - Full Node Available
     *
     * @generated from protobuf enum value: STATUS_ONLINE = 1;
     */
    ONLINE = 1,
    /**
     * Away - Not Online, but has a full node
     *
     * @generated from protobuf enum value: STATUS_AWAY = 2;
     */
    AWAY = 2,
    /**
     * Busy - Online, but busy with Transfer
     *
     * @generated from protobuf enum value: STATUS_BUSY = 3;
     */
    BUSY = 3
}
/**
 * General Information about Peer passed during Authentication
 *
 * @generated from protobuf message sonrio.sonr.registry.Profile
 */
export interface Profile {
    /**
     * @generated from protobuf field: string s_name = 1;
     */
    sName: string; // Sonr Based Username
    /**
     * @generated from protobuf field: string first_name = 2;
     */
    firstName: string; // General Info
    /**
     * @generated from protobuf field: string last_name = 3;
     */
    lastName: string; // General Info
    /**
     * @generated from protobuf field: bytes picture = 4;
     */
    picture: Uint8Array; // Profile Picture
    /**
     * @generated from protobuf field: string bio = 6;
     */
    bio: string; // User Biography
    /**
     * @generated from protobuf field: int64 last_modified = 7;
     */
    lastModified: string; // Last Modified Timestamp
}
/**
 * Internet Connection Type
 *
 * @generated from protobuf enum sonrio.sonr.registry.Connection
 */
export enum Connection {
    /**
     * @generated from protobuf enum value: CONNECTION_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * ConnectionWifi is used for WiFi connections.
     *
     * @generated from protobuf enum value: CONNECTION_WIFI = 1;
     */
    WIFI = 1,
    /**
     * ConnectionEthernet is used for Ethernet connections.
     *
     * @generated from protobuf enum value: CONNECTION_ETHERNET = 2;
     */
    ETHERNET = 2,
    /**
     * ConnectionMobile is used for mobile connections.
     *
     * @generated from protobuf enum value: CONNECTION_MOBILE = 3;
     */
    MOBILE = 3,
    /**
     * CONNECTION_OFFLINE
     *
     * No Internet Connection
     *
     * @generated from protobuf enum value: CONNECTION_OFFLINE = 4;
     */
    OFFLINE = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class Location$Type extends MessageType<Location> {
    constructor() {
        super("sonrio.sonr.registry.Location", [
            { no: 1, name: "latitude", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "longitude", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "placemark", kind: "message", T: () => Location_Placemark },
            { no: 4, name: "last_modified", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<Location>): Location {
        const message = { latitude: 0, longitude: 0, lastModified: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Location>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Location): Location {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double latitude */ 1:
                    message.latitude = reader.double();
                    break;
                case /* double longitude */ 2:
                    message.longitude = reader.double();
                    break;
                case /* sonrio.sonr.registry.Location.Placemark placemark */ 3:
                    message.placemark = Location_Placemark.internalBinaryRead(reader, reader.uint32(), options, message.placemark);
                    break;
                case /* int64 last_modified */ 4:
                    message.lastModified = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Location, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double latitude = 1; */
        if (message.latitude !== 0)
            writer.tag(1, WireType.Bit64).double(message.latitude);
        /* double longitude = 2; */
        if (message.longitude !== 0)
            writer.tag(2, WireType.Bit64).double(message.longitude);
        /* sonrio.sonr.registry.Location.Placemark placemark = 3; */
        if (message.placemark)
            Location_Placemark.internalBinaryWrite(message.placemark, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int64 last_modified = 4; */
        if (message.lastModified !== "0")
            writer.tag(4, WireType.Varint).int64(message.lastModified);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.registry.Location
 */
export const Location = new Location$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Location_Placemark$Type extends MessageType<Location_Placemark> {
    constructor() {
        super("sonrio.sonr.registry.Location.Placemark", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "street", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "iso_country_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "country", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "postal_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "administrative_area", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "sub_administrative_area", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "locality", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "sub_locality", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "thoroughfare", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "sub_thoroughfare", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Location_Placemark>): Location_Placemark {
        const message = { name: "", street: "", isoCountryCode: "", country: "", postalCode: "", administrativeArea: "", subAdministrativeArea: "", locality: "", subLocality: "", thoroughfare: "", subThoroughfare: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Location_Placemark>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Location_Placemark): Location_Placemark {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string street */ 2:
                    message.street = reader.string();
                    break;
                case /* string iso_country_code */ 3:
                    message.isoCountryCode = reader.string();
                    break;
                case /* string country */ 4:
                    message.country = reader.string();
                    break;
                case /* string postal_code */ 5:
                    message.postalCode = reader.string();
                    break;
                case /* string administrative_area */ 6:
                    message.administrativeArea = reader.string();
                    break;
                case /* string sub_administrative_area */ 7:
                    message.subAdministrativeArea = reader.string();
                    break;
                case /* string locality */ 8:
                    message.locality = reader.string();
                    break;
                case /* string sub_locality */ 9:
                    message.subLocality = reader.string();
                    break;
                case /* string thoroughfare */ 10:
                    message.thoroughfare = reader.string();
                    break;
                case /* string sub_thoroughfare */ 11:
                    message.subThoroughfare = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Location_Placemark, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string street = 2; */
        if (message.street !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.street);
        /* string iso_country_code = 3; */
        if (message.isoCountryCode !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.isoCountryCode);
        /* string country = 4; */
        if (message.country !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.country);
        /* string postal_code = 5; */
        if (message.postalCode !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.postalCode);
        /* string administrative_area = 6; */
        if (message.administrativeArea !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.administrativeArea);
        /* string sub_administrative_area = 7; */
        if (message.subAdministrativeArea !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.subAdministrativeArea);
        /* string locality = 8; */
        if (message.locality !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.locality);
        /* string sub_locality = 9; */
        if (message.subLocality !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.subLocality);
        /* string thoroughfare = 10; */
        if (message.thoroughfare !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.thoroughfare);
        /* string sub_thoroughfare = 11; */
        if (message.subThoroughfare !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.subThoroughfare);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.registry.Location.Placemark
 */
export const Location_Placemark = new Location_Placemark$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Metadata$Type extends MessageType<Metadata> {
    constructor() {
        super("sonrio.sonr.registry.Metadata", [
            { no: 1, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "signature", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "public_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Metadata>): Metadata {
        const message = { timestamp: "0", nodeId: "", signature: new Uint8Array(0), publicKey: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Metadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Metadata): Metadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 timestamp */ 1:
                    message.timestamp = reader.int64().toString();
                    break;
                case /* string node_id */ 2:
                    message.nodeId = reader.string();
                    break;
                case /* bytes signature */ 3:
                    message.signature = reader.bytes();
                    break;
                case /* bytes public_key */ 4:
                    message.publicKey = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Metadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 timestamp = 1; */
        if (message.timestamp !== "0")
            writer.tag(1, WireType.Varint).int64(message.timestamp);
        /* string node_id = 2; */
        if (message.nodeId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nodeId);
        /* bytes signature = 3; */
        if (message.signature.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.signature);
        /* bytes public_key = 4; */
        if (message.publicKey.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.publicKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.registry.Metadata
 */
export const Metadata = new Metadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Peer$Type extends MessageType<Peer> {
    constructor() {
        super("sonrio.sonr.registry.Peer", [
            { no: 1, name: "s_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "status", kind: "enum", T: () => ["sonrio.sonr.registry.Peer.Status", Peer_Status, "STATUS_"] },
            { no: 3, name: "device", kind: "message", T: () => Peer_Device },
            { no: 4, name: "profile", kind: "message", T: () => Profile },
            { no: 5, name: "public_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "peer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "last_modified", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<Peer>): Peer {
        const message = { sName: "", status: 0, publicKey: new Uint8Array(0), peerId: "", lastModified: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Peer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Peer): Peer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string s_name */ 1:
                    message.sName = reader.string();
                    break;
                case /* sonrio.sonr.registry.Peer.Status status */ 2:
                    message.status = reader.int32();
                    break;
                case /* sonrio.sonr.registry.Peer.Device device */ 3:
                    message.device = Peer_Device.internalBinaryRead(reader, reader.uint32(), options, message.device);
                    break;
                case /* sonrio.sonr.registry.Profile profile */ 4:
                    message.profile = Profile.internalBinaryRead(reader, reader.uint32(), options, message.profile);
                    break;
                case /* bytes public_key */ 5:
                    message.publicKey = reader.bytes();
                    break;
                case /* string peer_id */ 6:
                    message.peerId = reader.string();
                    break;
                case /* int64 last_modified */ 7:
                    message.lastModified = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Peer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string s_name = 1; */
        if (message.sName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sName);
        /* sonrio.sonr.registry.Peer.Status status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* sonrio.sonr.registry.Peer.Device device = 3; */
        if (message.device)
            Peer_Device.internalBinaryWrite(message.device, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* sonrio.sonr.registry.Profile profile = 4; */
        if (message.profile)
            Profile.internalBinaryWrite(message.profile, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bytes public_key = 5; */
        if (message.publicKey.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.publicKey);
        /* string peer_id = 6; */
        if (message.peerId !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.peerId);
        /* int64 last_modified = 7; */
        if (message.lastModified !== "0")
            writer.tag(7, WireType.Varint).int64(message.lastModified);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.registry.Peer
 */
export const Peer = new Peer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Peer_Device$Type extends MessageType<Peer_Device> {
    constructor() {
        super("sonrio.sonr.registry.Peer.Device", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "host_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "os", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "arch", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "model", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Peer_Device>): Peer_Device {
        const message = { id: "", hostName: "", os: "", arch: "", model: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Peer_Device>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Peer_Device): Peer_Device {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string host_name */ 2:
                    message.hostName = reader.string();
                    break;
                case /* string os */ 3:
                    message.os = reader.string();
                    break;
                case /* string arch */ 4:
                    message.arch = reader.string();
                    break;
                case /* string model */ 5:
                    message.model = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Peer_Device, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string host_name = 2; */
        if (message.hostName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.hostName);
        /* string os = 3; */
        if (message.os !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.os);
        /* string arch = 4; */
        if (message.arch !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.arch);
        /* string model = 5; */
        if (message.model !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.model);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.registry.Peer.Device
 */
export const Peer_Device = new Peer_Device$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Profile$Type extends MessageType<Profile> {
    constructor() {
        super("sonrio.sonr.registry.Profile", [
            { no: 1, name: "s_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "first_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "last_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "picture", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "bio", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "last_modified", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<Profile>): Profile {
        const message = { sName: "", firstName: "", lastName: "", picture: new Uint8Array(0), bio: "", lastModified: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Profile>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Profile): Profile {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string s_name */ 1:
                    message.sName = reader.string();
                    break;
                case /* string first_name */ 2:
                    message.firstName = reader.string();
                    break;
                case /* string last_name */ 3:
                    message.lastName = reader.string();
                    break;
                case /* bytes picture */ 4:
                    message.picture = reader.bytes();
                    break;
                case /* string bio */ 6:
                    message.bio = reader.string();
                    break;
                case /* int64 last_modified */ 7:
                    message.lastModified = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Profile, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string s_name = 1; */
        if (message.sName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sName);
        /* string first_name = 2; */
        if (message.firstName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.firstName);
        /* string last_name = 3; */
        if (message.lastName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.lastName);
        /* bytes picture = 4; */
        if (message.picture.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.picture);
        /* string bio = 6; */
        if (message.bio !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.bio);
        /* int64 last_modified = 7; */
        if (message.lastModified !== "0")
            writer.tag(7, WireType.Varint).int64(message.lastModified);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.registry.Profile
 */
export const Profile = new Profile$Type();
