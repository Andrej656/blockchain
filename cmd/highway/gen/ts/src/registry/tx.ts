// @generated by protobuf-ts 2.2.1 with parameter long_type_string,generate_dependencies
// @generated from protobuf file "registry/tx.proto" (package "sonrio.sonr.registry", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { DidDocument } from "./did";
import { Did } from "./did";
/**
 * @generated from protobuf message sonrio.sonr.registry.MsgRegisterService
 */
export interface MsgRegisterService {
    /**
     * @generated from protobuf field: string creator = 1;
     */
    creator: string;
    /**
     * @generated from protobuf field: string serviceName = 2;
     */
    serviceName: string;
    /**
     * @generated from protobuf field: string publicKey = 3;
     */
    publicKey: string;
}
/**
 * @generated from protobuf message sonrio.sonr.registry.MsgRegisterServiceResponse
 */
export interface MsgRegisterServiceResponse {
}
/**
 * MsgRegisterName is a request to register a name with the ".snr" name of a peer
 *
 * @generated from protobuf message sonrio.sonr.registry.MsgRegisterName
 */
export interface MsgRegisterName {
    /**
     * @generated from protobuf field: string creator = 1;
     */
    creator: string;
    /**
     * @generated from protobuf field: string deviceId = 2;
     */
    deviceId: string;
    /**
     * @generated from protobuf field: string os = 3;
     */
    os: string;
    /**
     * @generated from protobuf field: string model = 4;
     */
    model: string;
    /**
     * @generated from protobuf field: string arch = 5;
     */
    arch: string;
    /**
     * @generated from protobuf field: string publicKey = 6;
     */
    publicKey: string;
    /**
     * @generated from protobuf field: string nameToRegister = 7;
     */
    nameToRegister: string;
}
/**
 * @generated from protobuf message sonrio.sonr.registry.MsgRegisterNameResponse
 */
export interface MsgRegisterNameResponse {
    /**
     * @generated from protobuf field: bool isSuccess = 1;
     */
    isSuccess: boolean;
    /**
     * @generated from protobuf field: sonrio.sonr.registry.Did did = 2;
     */
    did?: Did;
    /**
     * @generated from protobuf field: sonrio.sonr.registry.DidDocument didDocument = 3;
     */
    didDocument?: DidDocument;
}
/**
 * MsgAccessName defines the MsgAccessName transaction.
 *
 * @generated from protobuf message sonrio.sonr.registry.MsgAccessName
 */
export interface MsgAccessName {
    /**
     * The account that is accessing the name
     *
     * @generated from protobuf field: string creator = 1;
     */
    creator: string;
    /**
     * The name to access
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * The Public Key of the peer to access
     *
     * @generated from protobuf field: string publicKey = 3;
     */
    publicKey: string;
    /**
     * The Libp2p peer ID of the peer to access
     *
     * @generated from protobuf field: string peerId = 4;
     */
    peerId: string;
}
/**
 * @generated from protobuf message sonrio.sonr.registry.MsgAccessNameResponse
 */
export interface MsgAccessNameResponse {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string publicKey = 2;
     */
    publicKey: string;
    /**
     * @generated from protobuf field: string peerId = 3;
     */
    peerId: string;
}
/**
 * @generated from protobuf message sonrio.sonr.registry.MsgUpdateName
 */
export interface MsgUpdateName {
    /**
     * The account that owns the name.
     *
     * @generated from protobuf field: string creator = 1;
     */
    creator: string;
    /**
     * The name of the peer to update the name of
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * The Updated Metadata
     *
     * @generated from protobuf field: map<string, string> metadata = 3;
     */
    metadata: {
        [key: string]: string;
    }; // optional
}
/**
 * @generated from protobuf message sonrio.sonr.registry.MsgUpdateNameResponse
 */
export interface MsgUpdateNameResponse {
    /**
     * @generated from protobuf field: sonrio.sonr.registry.DidDocument didDocument = 1;
     */
    didDocument?: DidDocument;
    /**
     * @generated from protobuf field: map<string, string> metadata = 2;
     */
    metadata: {
        [key: string]: string;
    }; // optional
}
/**
 * @generated from protobuf message sonrio.sonr.registry.MsgAccessService
 */
export interface MsgAccessService {
    /**
     * The account that is accessing the service
     *
     * @generated from protobuf field: string creator = 1;
     */
    creator: string;
    /**
     * The name of the service to access
     *
     * @generated from protobuf field: string did = 2;
     */
    did: string;
}
/**
 * @generated from protobuf message sonrio.sonr.registry.MsgAccessServiceResponse
 */
export interface MsgAccessServiceResponse {
    /**
     * Code of the response
     *
     * @generated from protobuf field: int32 code = 1;
     */
    code: number;
    /**
     * Message of the response
     *
     * @generated from protobuf field: string message = 2;
     */
    message: string;
    /**
     * Data of the response
     *
     * @generated from protobuf field: map<string, string> metadata = 3;
     */
    metadata: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message sonrio.sonr.registry.MsgUpdateService
 */
export interface MsgUpdateService {
    /**
     * The account that owns the name.
     *
     * @generated from protobuf field: string creator = 1;
     */
    creator: string;
    /**
     * The name of the peer to update the service details of
     *
     * @generated from protobuf field: string did = 2;
     */
    did: string;
    /**
     * The updated configuration for the service
     *
     * @generated from protobuf field: map<string, string> configuration = 3;
     */
    configuration: {
        [key: string]: string;
    };
    /**
     * The metadata for any service information required
     *
     * @generated from protobuf field: map<string, string> metadata = 4;
     */
    metadata: {
        [key: string]: string;
    }; // optional
}
/**
 * @generated from protobuf message sonrio.sonr.registry.MsgUpdateServiceResponse
 */
export interface MsgUpdateServiceResponse {
    /**
     * @generated from protobuf field: sonrio.sonr.registry.DidDocument didDocument = 1;
     */
    didDocument?: DidDocument;
    /**
     * The updated configuration for the service
     *
     * @generated from protobuf field: map<string, string> configuration = 2;
     */
    configuration: {
        [key: string]: string;
    };
    /**
     * The metadata for any service information required
     *
     * @generated from protobuf field: map<string, string> metadata = 3;
     */
    metadata: {
        [key: string]: string;
    }; // optional
}
// @generated message type with reflection information, may provide speed optimized methods
class MsgRegisterService$Type extends MessageType<MsgRegisterService> {
    constructor() {
        super("sonrio.sonr.registry.MsgRegisterService", [
            { no: 1, name: "creator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "serviceName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "publicKey", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MsgRegisterService>): MsgRegisterService {
        const message = { creator: "", serviceName: "", publicKey: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgRegisterService>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRegisterService): MsgRegisterService {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string creator */ 1:
                    message.creator = reader.string();
                    break;
                case /* string serviceName */ 2:
                    message.serviceName = reader.string();
                    break;
                case /* string publicKey */ 3:
                    message.publicKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRegisterService, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string creator = 1; */
        if (message.creator !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.creator);
        /* string serviceName = 2; */
        if (message.serviceName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.serviceName);
        /* string publicKey = 3; */
        if (message.publicKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.publicKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.registry.MsgRegisterService
 */
export const MsgRegisterService = new MsgRegisterService$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRegisterServiceResponse$Type extends MessageType<MsgRegisterServiceResponse> {
    constructor() {
        super("sonrio.sonr.registry.MsgRegisterServiceResponse", []);
    }
    create(value?: PartialMessage<MsgRegisterServiceResponse>): MsgRegisterServiceResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgRegisterServiceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRegisterServiceResponse): MsgRegisterServiceResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: MsgRegisterServiceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.registry.MsgRegisterServiceResponse
 */
export const MsgRegisterServiceResponse = new MsgRegisterServiceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRegisterName$Type extends MessageType<MsgRegisterName> {
    constructor() {
        super("sonrio.sonr.registry.MsgRegisterName", [
            { no: 1, name: "creator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "deviceId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "os", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "model", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "arch", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "publicKey", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "nameToRegister", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MsgRegisterName>): MsgRegisterName {
        const message = { creator: "", deviceId: "", os: "", model: "", arch: "", publicKey: "", nameToRegister: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgRegisterName>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRegisterName): MsgRegisterName {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string creator */ 1:
                    message.creator = reader.string();
                    break;
                case /* string deviceId */ 2:
                    message.deviceId = reader.string();
                    break;
                case /* string os */ 3:
                    message.os = reader.string();
                    break;
                case /* string model */ 4:
                    message.model = reader.string();
                    break;
                case /* string arch */ 5:
                    message.arch = reader.string();
                    break;
                case /* string publicKey */ 6:
                    message.publicKey = reader.string();
                    break;
                case /* string nameToRegister */ 7:
                    message.nameToRegister = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRegisterName, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string creator = 1; */
        if (message.creator !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.creator);
        /* string deviceId = 2; */
        if (message.deviceId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.deviceId);
        /* string os = 3; */
        if (message.os !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.os);
        /* string model = 4; */
        if (message.model !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.model);
        /* string arch = 5; */
        if (message.arch !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.arch);
        /* string publicKey = 6; */
        if (message.publicKey !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.publicKey);
        /* string nameToRegister = 7; */
        if (message.nameToRegister !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.nameToRegister);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.registry.MsgRegisterName
 */
export const MsgRegisterName = new MsgRegisterName$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRegisterNameResponse$Type extends MessageType<MsgRegisterNameResponse> {
    constructor() {
        super("sonrio.sonr.registry.MsgRegisterNameResponse", [
            { no: 1, name: "isSuccess", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "did", kind: "message", T: () => Did },
            { no: 3, name: "didDocument", kind: "message", T: () => DidDocument }
        ]);
    }
    create(value?: PartialMessage<MsgRegisterNameResponse>): MsgRegisterNameResponse {
        const message = { isSuccess: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgRegisterNameResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRegisterNameResponse): MsgRegisterNameResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool isSuccess */ 1:
                    message.isSuccess = reader.bool();
                    break;
                case /* sonrio.sonr.registry.Did did */ 2:
                    message.did = Did.internalBinaryRead(reader, reader.uint32(), options, message.did);
                    break;
                case /* sonrio.sonr.registry.DidDocument didDocument */ 3:
                    message.didDocument = DidDocument.internalBinaryRead(reader, reader.uint32(), options, message.didDocument);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRegisterNameResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool isSuccess = 1; */
        if (message.isSuccess !== false)
            writer.tag(1, WireType.Varint).bool(message.isSuccess);
        /* sonrio.sonr.registry.Did did = 2; */
        if (message.did)
            Did.internalBinaryWrite(message.did, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* sonrio.sonr.registry.DidDocument didDocument = 3; */
        if (message.didDocument)
            DidDocument.internalBinaryWrite(message.didDocument, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.registry.MsgRegisterNameResponse
 */
export const MsgRegisterNameResponse = new MsgRegisterNameResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgAccessName$Type extends MessageType<MsgAccessName> {
    constructor() {
        super("sonrio.sonr.registry.MsgAccessName", [
            { no: 1, name: "creator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "publicKey", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "peerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MsgAccessName>): MsgAccessName {
        const message = { creator: "", name: "", publicKey: "", peerId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgAccessName>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgAccessName): MsgAccessName {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string creator */ 1:
                    message.creator = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string publicKey */ 3:
                    message.publicKey = reader.string();
                    break;
                case /* string peerId */ 4:
                    message.peerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgAccessName, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string creator = 1; */
        if (message.creator !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.creator);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string publicKey = 3; */
        if (message.publicKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.publicKey);
        /* string peerId = 4; */
        if (message.peerId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.peerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.registry.MsgAccessName
 */
export const MsgAccessName = new MsgAccessName$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgAccessNameResponse$Type extends MessageType<MsgAccessNameResponse> {
    constructor() {
        super("sonrio.sonr.registry.MsgAccessNameResponse", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "publicKey", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "peerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MsgAccessNameResponse>): MsgAccessNameResponse {
        const message = { name: "", publicKey: "", peerId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgAccessNameResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgAccessNameResponse): MsgAccessNameResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string publicKey */ 2:
                    message.publicKey = reader.string();
                    break;
                case /* string peerId */ 3:
                    message.peerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgAccessNameResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string publicKey = 2; */
        if (message.publicKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.publicKey);
        /* string peerId = 3; */
        if (message.peerId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.peerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.registry.MsgAccessNameResponse
 */
export const MsgAccessNameResponse = new MsgAccessNameResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateName$Type extends MessageType<MsgUpdateName> {
    constructor() {
        super("sonrio.sonr.registry.MsgUpdateName", [
            { no: 1, name: "creator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<MsgUpdateName>): MsgUpdateName {
        const message = { creator: "", name: "", metadata: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateName>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateName): MsgUpdateName {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string creator */ 1:
                    message.creator = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* map<string, string> metadata */ 3:
                    this.binaryReadMap3(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: MsgUpdateName["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MsgUpdateName["metadata"] | undefined, val: MsgUpdateName["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field sonrio.sonr.registry.MsgUpdateName.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: MsgUpdateName, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string creator = 1; */
        if (message.creator !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.creator);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* map<string, string> metadata = 3; */
        for (let k of Object.keys(message.metadata))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.registry.MsgUpdateName
 */
export const MsgUpdateName = new MsgUpdateName$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateNameResponse$Type extends MessageType<MsgUpdateNameResponse> {
    constructor() {
        super("sonrio.sonr.registry.MsgUpdateNameResponse", [
            { no: 1, name: "didDocument", kind: "message", T: () => DidDocument },
            { no: 2, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<MsgUpdateNameResponse>): MsgUpdateNameResponse {
        const message = { metadata: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateNameResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateNameResponse): MsgUpdateNameResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sonrio.sonr.registry.DidDocument didDocument */ 1:
                    message.didDocument = DidDocument.internalBinaryRead(reader, reader.uint32(), options, message.didDocument);
                    break;
                case /* map<string, string> metadata */ 2:
                    this.binaryReadMap2(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: MsgUpdateNameResponse["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MsgUpdateNameResponse["metadata"] | undefined, val: MsgUpdateNameResponse["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field sonrio.sonr.registry.MsgUpdateNameResponse.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: MsgUpdateNameResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sonrio.sonr.registry.DidDocument didDocument = 1; */
        if (message.didDocument)
            DidDocument.internalBinaryWrite(message.didDocument, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* map<string, string> metadata = 2; */
        for (let k of Object.keys(message.metadata))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.registry.MsgUpdateNameResponse
 */
export const MsgUpdateNameResponse = new MsgUpdateNameResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgAccessService$Type extends MessageType<MsgAccessService> {
    constructor() {
        super("sonrio.sonr.registry.MsgAccessService", [
            { no: 1, name: "creator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "did", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MsgAccessService>): MsgAccessService {
        const message = { creator: "", did: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgAccessService>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgAccessService): MsgAccessService {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string creator */ 1:
                    message.creator = reader.string();
                    break;
                case /* string did */ 2:
                    message.did = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgAccessService, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string creator = 1; */
        if (message.creator !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.creator);
        /* string did = 2; */
        if (message.did !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.did);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.registry.MsgAccessService
 */
export const MsgAccessService = new MsgAccessService$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgAccessServiceResponse$Type extends MessageType<MsgAccessServiceResponse> {
    constructor() {
        super("sonrio.sonr.registry.MsgAccessServiceResponse", [
            { no: 1, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<MsgAccessServiceResponse>): MsgAccessServiceResponse {
        const message = { code: 0, message: "", metadata: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgAccessServiceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgAccessServiceResponse): MsgAccessServiceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 code */ 1:
                    message.code = reader.int32();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* map<string, string> metadata */ 3:
                    this.binaryReadMap3(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: MsgAccessServiceResponse["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MsgAccessServiceResponse["metadata"] | undefined, val: MsgAccessServiceResponse["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field sonrio.sonr.registry.MsgAccessServiceResponse.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: MsgAccessServiceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* map<string, string> metadata = 3; */
        for (let k of Object.keys(message.metadata))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.registry.MsgAccessServiceResponse
 */
export const MsgAccessServiceResponse = new MsgAccessServiceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateService$Type extends MessageType<MsgUpdateService> {
    constructor() {
        super("sonrio.sonr.registry.MsgUpdateService", [
            { no: 1, name: "creator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "did", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "configuration", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<MsgUpdateService>): MsgUpdateService {
        const message = { creator: "", did: "", configuration: {}, metadata: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateService>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateService): MsgUpdateService {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string creator */ 1:
                    message.creator = reader.string();
                    break;
                case /* string did */ 2:
                    message.did = reader.string();
                    break;
                case /* map<string, string> configuration */ 3:
                    this.binaryReadMap3(message.configuration, reader, options);
                    break;
                case /* map<string, string> metadata */ 4:
                    this.binaryReadMap4(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: MsgUpdateService["configuration"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MsgUpdateService["configuration"] | undefined, val: MsgUpdateService["configuration"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field sonrio.sonr.registry.MsgUpdateService.configuration");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap4(map: MsgUpdateService["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MsgUpdateService["metadata"] | undefined, val: MsgUpdateService["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field sonrio.sonr.registry.MsgUpdateService.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: MsgUpdateService, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string creator = 1; */
        if (message.creator !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.creator);
        /* string did = 2; */
        if (message.did !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.did);
        /* map<string, string> configuration = 3; */
        for (let k of Object.keys(message.configuration))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.configuration[k]).join();
        /* map<string, string> metadata = 4; */
        for (let k of Object.keys(message.metadata))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.registry.MsgUpdateService
 */
export const MsgUpdateService = new MsgUpdateService$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateServiceResponse$Type extends MessageType<MsgUpdateServiceResponse> {
    constructor() {
        super("sonrio.sonr.registry.MsgUpdateServiceResponse", [
            { no: 1, name: "didDocument", kind: "message", T: () => DidDocument },
            { no: 2, name: "configuration", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 3, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<MsgUpdateServiceResponse>): MsgUpdateServiceResponse {
        const message = { configuration: {}, metadata: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateServiceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateServiceResponse): MsgUpdateServiceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sonrio.sonr.registry.DidDocument didDocument */ 1:
                    message.didDocument = DidDocument.internalBinaryRead(reader, reader.uint32(), options, message.didDocument);
                    break;
                case /* map<string, string> configuration */ 2:
                    this.binaryReadMap2(message.configuration, reader, options);
                    break;
                case /* map<string, string> metadata */ 3:
                    this.binaryReadMap3(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: MsgUpdateServiceResponse["configuration"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MsgUpdateServiceResponse["configuration"] | undefined, val: MsgUpdateServiceResponse["configuration"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field sonrio.sonr.registry.MsgUpdateServiceResponse.configuration");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap3(map: MsgUpdateServiceResponse["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MsgUpdateServiceResponse["metadata"] | undefined, val: MsgUpdateServiceResponse["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field sonrio.sonr.registry.MsgUpdateServiceResponse.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: MsgUpdateServiceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sonrio.sonr.registry.DidDocument didDocument = 1; */
        if (message.didDocument)
            DidDocument.internalBinaryWrite(message.didDocument, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* map<string, string> configuration = 2; */
        for (let k of Object.keys(message.configuration))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.configuration[k]).join();
        /* map<string, string> metadata = 3; */
        for (let k of Object.keys(message.metadata))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.sonr.registry.MsgUpdateServiceResponse
 */
export const MsgUpdateServiceResponse = new MsgUpdateServiceResponse$Type();
/**
 * @generated ServiceType for protobuf service sonrio.sonr.registry.Msg
 */
export const Msg = new ServiceType("sonrio.sonr.registry.Msg", [
    { name: "RegisterService", options: {}, I: MsgRegisterService, O: MsgRegisterServiceResponse },
    { name: "RegisterName", options: {}, I: MsgRegisterName, O: MsgRegisterNameResponse },
    { name: "AccessName", options: {}, I: MsgAccessName, O: MsgAccessNameResponse },
    { name: "UpdateName", options: {}, I: MsgUpdateName, O: MsgUpdateNameResponse },
    { name: "AccessService", options: {}, I: MsgAccessService, O: MsgAccessServiceResponse },
    { name: "UpdateService", options: {}, I: MsgUpdateService, O: MsgUpdateServiceResponse }
]);
