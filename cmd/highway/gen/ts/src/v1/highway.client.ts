// @generated by protobuf-ts 2.2.1 with parameter long_type_string,generate_dependencies
// @generated from protobuf file "v1/highway.proto" (package "highway.v1", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { HighwayService } from "./highway";
import type { ResolveDidResponse } from "./response";
import type { ResolveDidRequest } from "./request";
import type { ParseDidResponse } from "./response";
import type { ParseDidRequest } from "./request";
import type { DeleteBlobResponse } from "./response";
import type { DeleteBlobRequest } from "./request";
import type { SyncBlobResponse } from "./response";
import type { SyncBlobRequest } from "./request";
import type { DownloadBlobResponse } from "./response";
import type { DownloadBlobRequest } from "./request";
import type { UploadBlobResponse } from "./response";
import type { UploadBlobRequest } from "./request";
import type { MsgDeleteObjectResponse } from "../object/tx";
import type { MsgDeleteObject } from "../object/tx";
import type { MsgUpdateObjectResponse } from "../object/tx";
import type { MsgUpdateObject } from "../object/tx";
import type { MsgReadObjectResponse } from "../object/tx";
import type { MsgReadObject } from "../object/tx";
import type { MsgCreateObjectResponse } from "../object/tx";
import type { MsgCreateObject } from "../object/tx";
import type { ListenBucketResponse } from "./response";
import type { ListenBucketRequest } from "./request";
import type { MsgDeleteBucketResponse } from "../bucket/tx";
import type { MsgDeleteBucket } from "../bucket/tx";
import type { MsgUpdateBucketResponse } from "../bucket/tx";
import type { MsgUpdateBucket } from "../bucket/tx";
import type { MsgReadBucketResponse } from "../bucket/tx";
import type { MsgReadBucket } from "../bucket/tx";
import type { MsgCreateBucketResponse } from "../bucket/tx";
import type { MsgCreateBucket } from "../bucket/tx";
import type { ChannelMessage } from "../channel/channel";
import type { ListenChannelRequest } from "./request";
import type { ServerStreamingCall } from "@protobuf-ts/runtime-rpc";
import type { MsgDeleteChannelResponse } from "../channel/tx";
import type { MsgDeleteChannel } from "../channel/tx";
import type { MsgUpdateChannelResponse } from "../channel/tx";
import type { MsgUpdateChannel } from "../channel/tx";
import type { MsgReadChannelResponse } from "../channel/tx";
import type { MsgReadChannel } from "../channel/tx";
import type { MsgCreateChannelResponse } from "../channel/tx";
import type { MsgCreateChannel } from "../channel/tx";
import type { MsgUpdateServiceResponse } from "../registry/tx";
import type { MsgUpdateService } from "../registry/tx";
import type { MsgRegisterServiceResponse } from "../registry/tx";
import type { MsgRegisterService } from "../registry/tx";
import type { AccessServiceResponse } from "./response";
import type { AccessServiceRequest } from "./request";
import type { MsgUpdateNameResponse } from "../registry/tx";
import type { MsgUpdateName } from "../registry/tx";
import type { MsgRegisterNameResponse } from "../registry/tx";
import type { MsgRegisterName } from "../registry/tx";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { AccessNameResponse } from "./response";
import type { AccessNameRequest } from "./request";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * HighwayService is a RPC service for interfacing over the Highway node.
 *
 * @generated from protobuf service highway.v1.HighwayService
 */
export interface IHighwayServiceClient {
    /**
     * AccessName returns details and publicly available information about the Peer given calling node
     * has permission to access. i.e "prad.snr" -> "firstname online profilePic city"
     *
     * @generated from protobuf rpc: AccessName(highway.v1.AccessNameRequest) returns (highway.v1.AccessNameResponse);
     */
    accessName(input: AccessNameRequest, options?: RpcOptions): UnaryCall<AccessNameRequest, AccessNameResponse>;
    /**
     * RegisterName registers a new ".snr" name for the calling node. It is only allowed to be called
     * once per node.
     *
     * @generated from protobuf rpc: RegisterName(sonrio.sonr.registry.MsgRegisterName) returns (sonrio.sonr.registry.MsgRegisterNameResponse);
     */
    registerName(input: MsgRegisterName, options?: RpcOptions): UnaryCall<MsgRegisterName, MsgRegisterNameResponse>;
    /**
     * UpdateName updates the public information of the calling node.
     *
     * @generated from protobuf rpc: UpdateName(sonrio.sonr.registry.MsgUpdateName) returns (sonrio.sonr.registry.MsgUpdateNameResponse);
     */
    updateName(input: MsgUpdateName, options?: RpcOptions): UnaryCall<MsgUpdateName, MsgUpdateNameResponse>;
    /**
     * AccessService creates a new signing key for the calling node in order to be authorized to
     * access the service. It is only allowed to be called once per node.
     *
     * @generated from protobuf rpc: AccessService(highway.v1.AccessServiceRequest) returns (highway.v1.AccessServiceResponse);
     */
    accessService(input: AccessServiceRequest, options?: RpcOptions): UnaryCall<AccessServiceRequest, AccessServiceResponse>;
    /**
     * RegisterService registers a new service for the calling node. The calling node must have
     * already been enabled for development.
     *
     * @generated from protobuf rpc: RegisterService(sonrio.sonr.registry.MsgRegisterService) returns (sonrio.sonr.registry.MsgRegisterServiceResponse);
     */
    registerService(input: MsgRegisterService, options?: RpcOptions): UnaryCall<MsgRegisterService, MsgRegisterServiceResponse>;
    /**
     * UpdateService updates the details and public configuration of the calling node's service.
     *
     * @generated from protobuf rpc: UpdateService(sonrio.sonr.registry.MsgUpdateService) returns (sonrio.sonr.registry.MsgUpdateServiceResponse);
     */
    updateService(input: MsgUpdateService, options?: RpcOptions): UnaryCall<MsgUpdateService, MsgUpdateServiceResponse>;
    /**
     * CreateChannel creates a new Publish/Subscribe topic channel for the given service.
     * The calling node must have already registered a service for the channel.
     *
     * @generated from protobuf rpc: CreateChannel(sonrio.sonr.channel.MsgCreateChannel) returns (sonrio.sonr.channel.MsgCreateChannelResponse);
     */
    createChannel(input: MsgCreateChannel, options?: RpcOptions): UnaryCall<MsgCreateChannel, MsgCreateChannelResponse>;
    /**
     * ReadChannel lists all peers subscribed to the given channel, and additional details about
     * the channels configuration.
     *
     * @generated from protobuf rpc: ReadChannel(sonrio.sonr.channel.MsgReadChannel) returns (sonrio.sonr.channel.MsgReadChannelResponse);
     */
    readChannel(input: MsgReadChannel, options?: RpcOptions): UnaryCall<MsgReadChannel, MsgReadChannelResponse>;
    /**
     * UpdateChannel updates the configuration of the given channel.
     *
     * @generated from protobuf rpc: UpdateChannel(sonrio.sonr.channel.MsgUpdateChannel) returns (sonrio.sonr.channel.MsgUpdateChannelResponse);
     */
    updateChannel(input: MsgUpdateChannel, options?: RpcOptions): UnaryCall<MsgUpdateChannel, MsgUpdateChannelResponse>;
    /**
     * DeleteChannel deletes the given channel if the calling node is the owner of the channel.
     *
     * @generated from protobuf rpc: DeleteChannel(sonrio.sonr.channel.MsgDeleteChannel) returns (sonrio.sonr.channel.MsgDeleteChannelResponse);
     */
    deleteChannel(input: MsgDeleteChannel, options?: RpcOptions): UnaryCall<MsgDeleteChannel, MsgDeleteChannelResponse>;
    /**
     * ListenChannel subscribes the calling node to the given channel and returns all publish events
     * as a stream.
     *
     * @generated from protobuf rpc: ListenChannel(highway.v1.ListenChannelRequest) returns (stream sonrio.sonr.channel.ChannelMessage);
     */
    listenChannel(input: ListenChannelRequest, options?: RpcOptions): ServerStreamingCall<ListenChannelRequest, ChannelMessage>;
    /**
     * CreateBucket creates a new bucket for the calling nodes service.
     *
     * @generated from protobuf rpc: CreateBucket(sonrio.sonr.bucket.MsgCreateBucket) returns (sonrio.sonr.bucket.MsgCreateBucketResponse);
     */
    createBucket(input: MsgCreateBucket, options?: RpcOptions): UnaryCall<MsgCreateBucket, MsgCreateBucketResponse>;
    /**
     * ReadBucket lists all the blobs in the given bucket. The calling node must have access to the
     * bucket.
     *
     * @generated from protobuf rpc: ReadBucket(sonrio.sonr.bucket.MsgReadBucket) returns (sonrio.sonr.bucket.MsgReadBucketResponse);
     */
    readBucket(input: MsgReadBucket, options?: RpcOptions): UnaryCall<MsgReadBucket, MsgReadBucketResponse>;
    /**
     * UpdateBucket updates the configuration of the given bucket. The calling node must have access
     * to the bucket.
     *
     * @generated from protobuf rpc: UpdateBucket(sonrio.sonr.bucket.MsgUpdateBucket) returns (sonrio.sonr.bucket.MsgUpdateBucketResponse);
     */
    updateBucket(input: MsgUpdateBucket, options?: RpcOptions): UnaryCall<MsgUpdateBucket, MsgUpdateBucketResponse>;
    /**
     * DeleteBucket deletes the given bucket if the calling node is the owner of the bucket.
     *
     * @generated from protobuf rpc: DeleteBucket(sonrio.sonr.bucket.MsgDeleteBucket) returns (sonrio.sonr.bucket.MsgDeleteBucketResponse);
     */
    deleteBucket(input: MsgDeleteBucket, options?: RpcOptions): UnaryCall<MsgDeleteBucket, MsgDeleteBucketResponse>;
    /**
     * ListenBucket subscribes the calling node to the given bucket and returns all publish events
     * as a stream.
     *
     * @generated from protobuf rpc: ListenBucket(highway.v1.ListenBucketRequest) returns (stream highway.v1.ListenBucketResponse);
     */
    listenBucket(input: ListenBucketRequest, options?: RpcOptions): ServerStreamingCall<ListenBucketRequest, ListenBucketResponse>;
    /**
     * CreateObject defines a new object to be utilized by the calling node's service. The object will
     * be placed in the Highway Service Graph and can be used in channels and other modules.
     *
     * @generated from protobuf rpc: CreateObject(sonrio.sonr.object.MsgCreateObject) returns (sonrio.sonr.object.MsgCreateObjectResponse);
     */
    createObject(input: MsgCreateObject, options?: RpcOptions): UnaryCall<MsgCreateObject, MsgCreateObjectResponse>;
    /**
     * ReadObject returns the details of the given object provided its DID or Label.
     *
     * @generated from protobuf rpc: ReadObject(sonrio.sonr.object.MsgReadObject) returns (sonrio.sonr.object.MsgReadObjectResponse);
     */
    readObject(input: MsgReadObject, options?: RpcOptions): UnaryCall<MsgReadObject, MsgReadObjectResponse>;
    /**
     * UpdateObject modifies the property fields of the given object.
     *
     * @generated from protobuf rpc: UpdateObject(sonrio.sonr.object.MsgUpdateObject) returns (sonrio.sonr.object.MsgUpdateObjectResponse);
     */
    updateObject(input: MsgUpdateObject, options?: RpcOptions): UnaryCall<MsgUpdateObject, MsgUpdateObjectResponse>;
    /**
     * DeleteObject deletes the given object if the calling node is the owner of the object.
     *
     * @generated from protobuf rpc: DeleteObject(sonrio.sonr.object.MsgDeleteObject) returns (sonrio.sonr.object.MsgDeleteObjectResponse);
     */
    deleteObject(input: MsgDeleteObject, options?: RpcOptions): UnaryCall<MsgDeleteObject, MsgDeleteObjectResponse>;
    /**
     * UploadBlob uploads a file or buffer to the calling node's service IPFS storage.
     *
     * @generated from protobuf rpc: UploadBlob(highway.v1.UploadBlobRequest) returns (stream highway.v1.UploadBlobResponse);
     */
    uploadBlob(input: UploadBlobRequest, options?: RpcOptions): ServerStreamingCall<UploadBlobRequest, UploadBlobResponse>;
    /**
     * DownloadBlob downloads a file or buffer from the calling node's service IPFS storage.
     *
     * @generated from protobuf rpc: DownloadBlob(highway.v1.DownloadBlobRequest) returns (stream highway.v1.DownloadBlobResponse);
     */
    downloadBlob(input: DownloadBlobRequest, options?: RpcOptions): ServerStreamingCall<DownloadBlobRequest, DownloadBlobResponse>;
    /**
     * SyncBlob synchronizes a local file from the calling node to the given service's IPFS storage.
     *
     * @generated from protobuf rpc: SyncBlob(highway.v1.SyncBlobRequest) returns (stream highway.v1.SyncBlobResponse);
     */
    syncBlob(input: SyncBlobRequest, options?: RpcOptions): ServerStreamingCall<SyncBlobRequest, SyncBlobResponse>;
    /**
     * DeleteBlob deletes the given file from the calling node's service IPFS storage.
     *
     * @generated from protobuf rpc: DeleteBlob(highway.v1.DeleteBlobRequest) returns (highway.v1.DeleteBlobResponse);
     */
    deleteBlob(input: DeleteBlobRequest, options?: RpcOptions): UnaryCall<DeleteBlobRequest, DeleteBlobResponse>;
    /**
     * ParseDid parses a potential DID string into a DID object.
     *
     * @generated from protobuf rpc: ParseDid(highway.v1.ParseDidRequest) returns (highway.v1.ParseDidResponse);
     */
    parseDid(input: ParseDidRequest, options?: RpcOptions): UnaryCall<ParseDidRequest, ParseDidResponse>;
    /**
     * ResolveDid resolves a DID to its DID document if the DID is valid and the calling node has
     * access to the DID Document.
     *
     * @generated from protobuf rpc: ResolveDid(highway.v1.ResolveDidRequest) returns (highway.v1.ResolveDidResponse);
     */
    resolveDid(input: ResolveDidRequest, options?: RpcOptions): UnaryCall<ResolveDidRequest, ResolveDidResponse>;
}
/**
 * HighwayService is a RPC service for interfacing over the Highway node.
 *
 * @generated from protobuf service highway.v1.HighwayService
 */
export class HighwayServiceClient implements IHighwayServiceClient, ServiceInfo {
    typeName = HighwayService.typeName;
    methods = HighwayService.methods;
    options = HighwayService.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * AccessName returns details and publicly available information about the Peer given calling node
     * has permission to access. i.e "prad.snr" -> "firstname online profilePic city"
     *
     * @generated from protobuf rpc: AccessName(highway.v1.AccessNameRequest) returns (highway.v1.AccessNameResponse);
     */
    accessName(input: AccessNameRequest, options?: RpcOptions): UnaryCall<AccessNameRequest, AccessNameResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<AccessNameRequest, AccessNameResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * RegisterName registers a new ".snr" name for the calling node. It is only allowed to be called
     * once per node.
     *
     * @generated from protobuf rpc: RegisterName(sonrio.sonr.registry.MsgRegisterName) returns (sonrio.sonr.registry.MsgRegisterNameResponse);
     */
    registerName(input: MsgRegisterName, options?: RpcOptions): UnaryCall<MsgRegisterName, MsgRegisterNameResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<MsgRegisterName, MsgRegisterNameResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * UpdateName updates the public information of the calling node.
     *
     * @generated from protobuf rpc: UpdateName(sonrio.sonr.registry.MsgUpdateName) returns (sonrio.sonr.registry.MsgUpdateNameResponse);
     */
    updateName(input: MsgUpdateName, options?: RpcOptions): UnaryCall<MsgUpdateName, MsgUpdateNameResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<MsgUpdateName, MsgUpdateNameResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * AccessService creates a new signing key for the calling node in order to be authorized to
     * access the service. It is only allowed to be called once per node.
     *
     * @generated from protobuf rpc: AccessService(highway.v1.AccessServiceRequest) returns (highway.v1.AccessServiceResponse);
     */
    accessService(input: AccessServiceRequest, options?: RpcOptions): UnaryCall<AccessServiceRequest, AccessServiceResponse> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<AccessServiceRequest, AccessServiceResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * RegisterService registers a new service for the calling node. The calling node must have
     * already been enabled for development.
     *
     * @generated from protobuf rpc: RegisterService(sonrio.sonr.registry.MsgRegisterService) returns (sonrio.sonr.registry.MsgRegisterServiceResponse);
     */
    registerService(input: MsgRegisterService, options?: RpcOptions): UnaryCall<MsgRegisterService, MsgRegisterServiceResponse> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<MsgRegisterService, MsgRegisterServiceResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * UpdateService updates the details and public configuration of the calling node's service.
     *
     * @generated from protobuf rpc: UpdateService(sonrio.sonr.registry.MsgUpdateService) returns (sonrio.sonr.registry.MsgUpdateServiceResponse);
     */
    updateService(input: MsgUpdateService, options?: RpcOptions): UnaryCall<MsgUpdateService, MsgUpdateServiceResponse> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<MsgUpdateService, MsgUpdateServiceResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * CreateChannel creates a new Publish/Subscribe topic channel for the given service.
     * The calling node must have already registered a service for the channel.
     *
     * @generated from protobuf rpc: CreateChannel(sonrio.sonr.channel.MsgCreateChannel) returns (sonrio.sonr.channel.MsgCreateChannelResponse);
     */
    createChannel(input: MsgCreateChannel, options?: RpcOptions): UnaryCall<MsgCreateChannel, MsgCreateChannelResponse> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept<MsgCreateChannel, MsgCreateChannelResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ReadChannel lists all peers subscribed to the given channel, and additional details about
     * the channels configuration.
     *
     * @generated from protobuf rpc: ReadChannel(sonrio.sonr.channel.MsgReadChannel) returns (sonrio.sonr.channel.MsgReadChannelResponse);
     */
    readChannel(input: MsgReadChannel, options?: RpcOptions): UnaryCall<MsgReadChannel, MsgReadChannelResponse> {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return stackIntercept<MsgReadChannel, MsgReadChannelResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * UpdateChannel updates the configuration of the given channel.
     *
     * @generated from protobuf rpc: UpdateChannel(sonrio.sonr.channel.MsgUpdateChannel) returns (sonrio.sonr.channel.MsgUpdateChannelResponse);
     */
    updateChannel(input: MsgUpdateChannel, options?: RpcOptions): UnaryCall<MsgUpdateChannel, MsgUpdateChannelResponse> {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        return stackIntercept<MsgUpdateChannel, MsgUpdateChannelResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * DeleteChannel deletes the given channel if the calling node is the owner of the channel.
     *
     * @generated from protobuf rpc: DeleteChannel(sonrio.sonr.channel.MsgDeleteChannel) returns (sonrio.sonr.channel.MsgDeleteChannelResponse);
     */
    deleteChannel(input: MsgDeleteChannel, options?: RpcOptions): UnaryCall<MsgDeleteChannel, MsgDeleteChannelResponse> {
        const method = this.methods[9], opt = this._transport.mergeOptions(options);
        return stackIntercept<MsgDeleteChannel, MsgDeleteChannelResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ListenChannel subscribes the calling node to the given channel and returns all publish events
     * as a stream.
     *
     * @generated from protobuf rpc: ListenChannel(highway.v1.ListenChannelRequest) returns (stream sonrio.sonr.channel.ChannelMessage);
     */
    listenChannel(input: ListenChannelRequest, options?: RpcOptions): ServerStreamingCall<ListenChannelRequest, ChannelMessage> {
        const method = this.methods[10], opt = this._transport.mergeOptions(options);
        return stackIntercept<ListenChannelRequest, ChannelMessage>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * CreateBucket creates a new bucket for the calling nodes service.
     *
     * @generated from protobuf rpc: CreateBucket(sonrio.sonr.bucket.MsgCreateBucket) returns (sonrio.sonr.bucket.MsgCreateBucketResponse);
     */
    createBucket(input: MsgCreateBucket, options?: RpcOptions): UnaryCall<MsgCreateBucket, MsgCreateBucketResponse> {
        const method = this.methods[11], opt = this._transport.mergeOptions(options);
        return stackIntercept<MsgCreateBucket, MsgCreateBucketResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ReadBucket lists all the blobs in the given bucket. The calling node must have access to the
     * bucket.
     *
     * @generated from protobuf rpc: ReadBucket(sonrio.sonr.bucket.MsgReadBucket) returns (sonrio.sonr.bucket.MsgReadBucketResponse);
     */
    readBucket(input: MsgReadBucket, options?: RpcOptions): UnaryCall<MsgReadBucket, MsgReadBucketResponse> {
        const method = this.methods[12], opt = this._transport.mergeOptions(options);
        return stackIntercept<MsgReadBucket, MsgReadBucketResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * UpdateBucket updates the configuration of the given bucket. The calling node must have access
     * to the bucket.
     *
     * @generated from protobuf rpc: UpdateBucket(sonrio.sonr.bucket.MsgUpdateBucket) returns (sonrio.sonr.bucket.MsgUpdateBucketResponse);
     */
    updateBucket(input: MsgUpdateBucket, options?: RpcOptions): UnaryCall<MsgUpdateBucket, MsgUpdateBucketResponse> {
        const method = this.methods[13], opt = this._transport.mergeOptions(options);
        return stackIntercept<MsgUpdateBucket, MsgUpdateBucketResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * DeleteBucket deletes the given bucket if the calling node is the owner of the bucket.
     *
     * @generated from protobuf rpc: DeleteBucket(sonrio.sonr.bucket.MsgDeleteBucket) returns (sonrio.sonr.bucket.MsgDeleteBucketResponse);
     */
    deleteBucket(input: MsgDeleteBucket, options?: RpcOptions): UnaryCall<MsgDeleteBucket, MsgDeleteBucketResponse> {
        const method = this.methods[14], opt = this._transport.mergeOptions(options);
        return stackIntercept<MsgDeleteBucket, MsgDeleteBucketResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ListenBucket subscribes the calling node to the given bucket and returns all publish events
     * as a stream.
     *
     * @generated from protobuf rpc: ListenBucket(highway.v1.ListenBucketRequest) returns (stream highway.v1.ListenBucketResponse);
     */
    listenBucket(input: ListenBucketRequest, options?: RpcOptions): ServerStreamingCall<ListenBucketRequest, ListenBucketResponse> {
        const method = this.methods[15], opt = this._transport.mergeOptions(options);
        return stackIntercept<ListenBucketRequest, ListenBucketResponse>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * CreateObject defines a new object to be utilized by the calling node's service. The object will
     * be placed in the Highway Service Graph and can be used in channels and other modules.
     *
     * @generated from protobuf rpc: CreateObject(sonrio.sonr.object.MsgCreateObject) returns (sonrio.sonr.object.MsgCreateObjectResponse);
     */
    createObject(input: MsgCreateObject, options?: RpcOptions): UnaryCall<MsgCreateObject, MsgCreateObjectResponse> {
        const method = this.methods[16], opt = this._transport.mergeOptions(options);
        return stackIntercept<MsgCreateObject, MsgCreateObjectResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ReadObject returns the details of the given object provided its DID or Label.
     *
     * @generated from protobuf rpc: ReadObject(sonrio.sonr.object.MsgReadObject) returns (sonrio.sonr.object.MsgReadObjectResponse);
     */
    readObject(input: MsgReadObject, options?: RpcOptions): UnaryCall<MsgReadObject, MsgReadObjectResponse> {
        const method = this.methods[17], opt = this._transport.mergeOptions(options);
        return stackIntercept<MsgReadObject, MsgReadObjectResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * UpdateObject modifies the property fields of the given object.
     *
     * @generated from protobuf rpc: UpdateObject(sonrio.sonr.object.MsgUpdateObject) returns (sonrio.sonr.object.MsgUpdateObjectResponse);
     */
    updateObject(input: MsgUpdateObject, options?: RpcOptions): UnaryCall<MsgUpdateObject, MsgUpdateObjectResponse> {
        const method = this.methods[18], opt = this._transport.mergeOptions(options);
        return stackIntercept<MsgUpdateObject, MsgUpdateObjectResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * DeleteObject deletes the given object if the calling node is the owner of the object.
     *
     * @generated from protobuf rpc: DeleteObject(sonrio.sonr.object.MsgDeleteObject) returns (sonrio.sonr.object.MsgDeleteObjectResponse);
     */
    deleteObject(input: MsgDeleteObject, options?: RpcOptions): UnaryCall<MsgDeleteObject, MsgDeleteObjectResponse> {
        const method = this.methods[19], opt = this._transport.mergeOptions(options);
        return stackIntercept<MsgDeleteObject, MsgDeleteObjectResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * UploadBlob uploads a file or buffer to the calling node's service IPFS storage.
     *
     * @generated from protobuf rpc: UploadBlob(highway.v1.UploadBlobRequest) returns (stream highway.v1.UploadBlobResponse);
     */
    uploadBlob(input: UploadBlobRequest, options?: RpcOptions): ServerStreamingCall<UploadBlobRequest, UploadBlobResponse> {
        const method = this.methods[20], opt = this._transport.mergeOptions(options);
        return stackIntercept<UploadBlobRequest, UploadBlobResponse>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * DownloadBlob downloads a file or buffer from the calling node's service IPFS storage.
     *
     * @generated from protobuf rpc: DownloadBlob(highway.v1.DownloadBlobRequest) returns (stream highway.v1.DownloadBlobResponse);
     */
    downloadBlob(input: DownloadBlobRequest, options?: RpcOptions): ServerStreamingCall<DownloadBlobRequest, DownloadBlobResponse> {
        const method = this.methods[21], opt = this._transport.mergeOptions(options);
        return stackIntercept<DownloadBlobRequest, DownloadBlobResponse>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * SyncBlob synchronizes a local file from the calling node to the given service's IPFS storage.
     *
     * @generated from protobuf rpc: SyncBlob(highway.v1.SyncBlobRequest) returns (stream highway.v1.SyncBlobResponse);
     */
    syncBlob(input: SyncBlobRequest, options?: RpcOptions): ServerStreamingCall<SyncBlobRequest, SyncBlobResponse> {
        const method = this.methods[22], opt = this._transport.mergeOptions(options);
        return stackIntercept<SyncBlobRequest, SyncBlobResponse>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * DeleteBlob deletes the given file from the calling node's service IPFS storage.
     *
     * @generated from protobuf rpc: DeleteBlob(highway.v1.DeleteBlobRequest) returns (highway.v1.DeleteBlobResponse);
     */
    deleteBlob(input: DeleteBlobRequest, options?: RpcOptions): UnaryCall<DeleteBlobRequest, DeleteBlobResponse> {
        const method = this.methods[23], opt = this._transport.mergeOptions(options);
        return stackIntercept<DeleteBlobRequest, DeleteBlobResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ParseDid parses a potential DID string into a DID object.
     *
     * @generated from protobuf rpc: ParseDid(highway.v1.ParseDidRequest) returns (highway.v1.ParseDidResponse);
     */
    parseDid(input: ParseDidRequest, options?: RpcOptions): UnaryCall<ParseDidRequest, ParseDidResponse> {
        const method = this.methods[24], opt = this._transport.mergeOptions(options);
        return stackIntercept<ParseDidRequest, ParseDidResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ResolveDid resolves a DID to its DID document if the DID is valid and the calling node has
     * access to the DID Document.
     *
     * @generated from protobuf rpc: ResolveDid(highway.v1.ResolveDidRequest) returns (highway.v1.ResolveDidResponse);
     */
    resolveDid(input: ResolveDidRequest, options?: RpcOptions): UnaryCall<ResolveDidRequest, ResolveDidResponse> {
        const method = this.methods[25], opt = this._transport.mergeOptions(options);
        return stackIntercept<ResolveDidRequest, ResolveDidResponse>("unary", this._transport, method, opt, input);
    }
}
