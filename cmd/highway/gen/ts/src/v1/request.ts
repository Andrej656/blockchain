// @generated by protobuf-ts 2.2.1 with parameter long_type_string,generate_dependencies
// @generated from protobuf file "v1/request.proto" (package "highway.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * AccessNameRequest is a request to get details from the ".snr" name of a peer
 *
 * @generated from protobuf message highway.v1.AccessNameRequest
 */
export interface AccessNameRequest {
    /**
     * The name of the peer to get the details from
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The public key of the peer to get the details from
     *
     * @generated from protobuf field: string public_key = 3;
     */
    publicKey: string; // optional
}
/**
 * AccessServiceRequest is a request to get the service details of a peer
 *
 * @generated from protobuf message highway.v1.AccessServiceRequest
 */
export interface AccessServiceRequest {
    /**
     * The name of the peer to get the service details of
     *
     * @generated from protobuf field: string did = 1;
     */
    did: string;
    /**
     * The metadata for any service information required
     *
     * @generated from protobuf field: map<string, string> metadata = 2;
     */
    metadata: {
        [key: string]: string;
    }; // optional
}
/**
 * ListenChannelRequest is the request to subscribe to a channel
 *
 * @generated from protobuf message highway.v1.ListenChannelRequest
 */
export interface ListenChannelRequest {
    /**
     * Name is the name of the channel
     *
     * @generated from protobuf field: string did = 1;
     */
    did: string;
    /**
     * Metadata is additional metadata for the channel
     *
     * @generated from protobuf field: map<string, string> metadata = 2;
     */
    metadata: {
        [key: string]: string;
    }; // optional
}
/**
 * ListenBucketRequest is the request to subscribe to a bucket
 *
 * @generated from protobuf message highway.v1.ListenBucketRequest
 */
export interface ListenBucketRequest {
    /**
     * DID is the DID of the bucket
     *
     * @generated from protobuf field: string did = 1;
     */
    did: string;
    /**
     * Metadata is the metadata of the bucket thats being listened to
     *
     * @generated from protobuf field: map<string, string> metadata = 2;
     */
    metadata: {
        [key: string]: string;
    }; // optional
}
/**
 * UploadBlobRequest is the request to upload a blob
 *
 * @generated from protobuf message highway.v1.UploadBlobRequest
 */
export interface UploadBlobRequest {
    /**
     * Label is the label of the blob
     *
     * @generated from protobuf field: string label = 1;
     */
    label: string;
    /**
     * Path is the path of the blob
     *
     * @generated from protobuf field: string path = 2;
     */
    path: string;
    /**
     * Bucket or object DID where the blob is being uploaded to
     *
     * @generated from protobuf field: string ref_did = 3;
     */
    refDid: string;
    /**
     * Size is the size of the blob
     *
     * @generated from protobuf field: int64 size = 4;
     */
    size: string;
    /**
     * LastModified is the last modified time of the blob
     *
     * @generated from protobuf field: int64 last_modified = 5;
     */
    lastModified: string;
}
/**
 * DownloadBlobRequest is the request to download a blob
 *
 * @generated from protobuf message highway.v1.DownloadBlobRequest
 */
export interface DownloadBlobRequest {
    /**
     * DID is the identifier of the blob
     *
     * @generated from protobuf field: string did = 1;
     */
    did: string;
    /**
     * Out Path is the download path of the blob
     *
     * @generated from protobuf field: string out_path = 2;
     */
    outPath: string;
}
/**
 * SyncBlobRequest is the request to sync a blob
 *
 * @generated from protobuf message highway.v1.SyncBlobRequest
 */
export interface SyncBlobRequest {
    /**
     * DID is the identifier of the blob
     *
     * @generated from protobuf field: string did = 1;
     */
    did: string;
    /**
     * Path is the location of the blob
     *
     * @generated from protobuf field: string path = 2;
     */
    path: string;
    /**
     * @generated from protobuf field: int32 timeout = 3;
     */
    timeout: number; // optional
}
/**
 * DeleteBlobRequest is the request to delete a blob
 *
 * @generated from protobuf message highway.v1.DeleteBlobRequest
 */
export interface DeleteBlobRequest {
    /**
     * DID is the identifier of the blob
     *
     * @generated from protobuf field: string did = 1;
     */
    did: string;
    /**
     * Metadata is the metadata of the blob thats being deleted
     *
     * @generated from protobuf field: map<string, string> metadata = 2;
     */
    metadata: {
        [key: string]: string;
    };
    /**
     * Public key of the node that is deleting the blob
     *
     * @generated from protobuf field: string public_key = 3;
     */
    publicKey: string;
}
/**
 * ParseDidRequest is the request to convert a string to a DID object
 *
 * @generated from protobuf message highway.v1.ParseDidRequest
 */
export interface ParseDidRequest {
    /**
     * DID is the DID of the DID
     *
     * @generated from protobuf field: string did = 1;
     */
    did: string;
    /**
     * Metadata is the metadata of the blob thats being deleted
     *
     * @generated from protobuf field: map<string, string> metadata = 2;
     */
    metadata: {
        [key: string]: string;
    };
}
/**
 * ResolveDidRequest is the request to resolve a DID
 *
 * @generated from protobuf message highway.v1.ResolveDidRequest
 */
export interface ResolveDidRequest {
    /**
     * DID is the DID of the DID
     *
     * @generated from protobuf field: string did = 1;
     */
    did: string;
    /**
     * Metadata is the metadata of the blob thats being deleted
     *
     * @generated from protobuf field: map<string, string> metadata = 2;
     */
    metadata: {
        [key: string]: string;
    };
}
// @generated message type with reflection information, may provide speed optimized methods
class AccessNameRequest$Type extends MessageType<AccessNameRequest> {
    constructor() {
        super("highway.v1.AccessNameRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "public_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AccessNameRequest>): AccessNameRequest {
        const message = { name: "", publicKey: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccessNameRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessNameRequest): AccessNameRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string public_key */ 3:
                    message.publicKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessNameRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string public_key = 3; */
        if (message.publicKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.publicKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message highway.v1.AccessNameRequest
 */
export const AccessNameRequest = new AccessNameRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessServiceRequest$Type extends MessageType<AccessServiceRequest> {
    constructor() {
        super("highway.v1.AccessServiceRequest", [
            { no: 1, name: "did", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<AccessServiceRequest>): AccessServiceRequest {
        const message = { did: "", metadata: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccessServiceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessServiceRequest): AccessServiceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string did */ 1:
                    message.did = reader.string();
                    break;
                case /* map<string, string> metadata */ 2:
                    this.binaryReadMap2(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: AccessServiceRequest["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AccessServiceRequest["metadata"] | undefined, val: AccessServiceRequest["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field highway.v1.AccessServiceRequest.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: AccessServiceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string did = 1; */
        if (message.did !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.did);
        /* map<string, string> metadata = 2; */
        for (let k of Object.keys(message.metadata))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message highway.v1.AccessServiceRequest
 */
export const AccessServiceRequest = new AccessServiceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListenChannelRequest$Type extends MessageType<ListenChannelRequest> {
    constructor() {
        super("highway.v1.ListenChannelRequest", [
            { no: 1, name: "did", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<ListenChannelRequest>): ListenChannelRequest {
        const message = { did: "", metadata: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListenChannelRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListenChannelRequest): ListenChannelRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string did */ 1:
                    message.did = reader.string();
                    break;
                case /* map<string, string> metadata */ 2:
                    this.binaryReadMap2(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: ListenChannelRequest["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ListenChannelRequest["metadata"] | undefined, val: ListenChannelRequest["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field highway.v1.ListenChannelRequest.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: ListenChannelRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string did = 1; */
        if (message.did !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.did);
        /* map<string, string> metadata = 2; */
        for (let k of Object.keys(message.metadata))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message highway.v1.ListenChannelRequest
 */
export const ListenChannelRequest = new ListenChannelRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListenBucketRequest$Type extends MessageType<ListenBucketRequest> {
    constructor() {
        super("highway.v1.ListenBucketRequest", [
            { no: 1, name: "did", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<ListenBucketRequest>): ListenBucketRequest {
        const message = { did: "", metadata: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListenBucketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListenBucketRequest): ListenBucketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string did */ 1:
                    message.did = reader.string();
                    break;
                case /* map<string, string> metadata */ 2:
                    this.binaryReadMap2(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: ListenBucketRequest["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ListenBucketRequest["metadata"] | undefined, val: ListenBucketRequest["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field highway.v1.ListenBucketRequest.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: ListenBucketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string did = 1; */
        if (message.did !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.did);
        /* map<string, string> metadata = 2; */
        for (let k of Object.keys(message.metadata))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message highway.v1.ListenBucketRequest
 */
export const ListenBucketRequest = new ListenBucketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadBlobRequest$Type extends MessageType<UploadBlobRequest> {
    constructor() {
        super("highway.v1.UploadBlobRequest", [
            { no: 1, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ref_did", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "size", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 5, name: "last_modified", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<UploadBlobRequest>): UploadBlobRequest {
        const message = { label: "", path: "", refDid: "", size: "0", lastModified: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UploadBlobRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadBlobRequest): UploadBlobRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* string path */ 2:
                    message.path = reader.string();
                    break;
                case /* string ref_did */ 3:
                    message.refDid = reader.string();
                    break;
                case /* int64 size */ 4:
                    message.size = reader.int64().toString();
                    break;
                case /* int64 last_modified */ 5:
                    message.lastModified = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadBlobRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* string path = 2; */
        if (message.path !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.path);
        /* string ref_did = 3; */
        if (message.refDid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.refDid);
        /* int64 size = 4; */
        if (message.size !== "0")
            writer.tag(4, WireType.Varint).int64(message.size);
        /* int64 last_modified = 5; */
        if (message.lastModified !== "0")
            writer.tag(5, WireType.Varint).int64(message.lastModified);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message highway.v1.UploadBlobRequest
 */
export const UploadBlobRequest = new UploadBlobRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DownloadBlobRequest$Type extends MessageType<DownloadBlobRequest> {
    constructor() {
        super("highway.v1.DownloadBlobRequest", [
            { no: 1, name: "did", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "out_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DownloadBlobRequest>): DownloadBlobRequest {
        const message = { did: "", outPath: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DownloadBlobRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DownloadBlobRequest): DownloadBlobRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string did */ 1:
                    message.did = reader.string();
                    break;
                case /* string out_path */ 2:
                    message.outPath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DownloadBlobRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string did = 1; */
        if (message.did !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.did);
        /* string out_path = 2; */
        if (message.outPath !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.outPath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message highway.v1.DownloadBlobRequest
 */
export const DownloadBlobRequest = new DownloadBlobRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SyncBlobRequest$Type extends MessageType<SyncBlobRequest> {
    constructor() {
        super("highway.v1.SyncBlobRequest", [
            { no: 1, name: "did", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timeout", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SyncBlobRequest>): SyncBlobRequest {
        const message = { did: "", path: "", timeout: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SyncBlobRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SyncBlobRequest): SyncBlobRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string did */ 1:
                    message.did = reader.string();
                    break;
                case /* string path */ 2:
                    message.path = reader.string();
                    break;
                case /* int32 timeout */ 3:
                    message.timeout = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SyncBlobRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string did = 1; */
        if (message.did !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.did);
        /* string path = 2; */
        if (message.path !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.path);
        /* int32 timeout = 3; */
        if (message.timeout !== 0)
            writer.tag(3, WireType.Varint).int32(message.timeout);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message highway.v1.SyncBlobRequest
 */
export const SyncBlobRequest = new SyncBlobRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteBlobRequest$Type extends MessageType<DeleteBlobRequest> {
    constructor() {
        super("highway.v1.DeleteBlobRequest", [
            { no: 1, name: "did", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 3, name: "public_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteBlobRequest>): DeleteBlobRequest {
        const message = { did: "", metadata: {}, publicKey: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteBlobRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteBlobRequest): DeleteBlobRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string did */ 1:
                    message.did = reader.string();
                    break;
                case /* map<string, string> metadata */ 2:
                    this.binaryReadMap2(message.metadata, reader, options);
                    break;
                case /* string public_key */ 3:
                    message.publicKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: DeleteBlobRequest["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DeleteBlobRequest["metadata"] | undefined, val: DeleteBlobRequest["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field highway.v1.DeleteBlobRequest.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: DeleteBlobRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string did = 1; */
        if (message.did !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.did);
        /* map<string, string> metadata = 2; */
        for (let k of Object.keys(message.metadata))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        /* string public_key = 3; */
        if (message.publicKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.publicKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message highway.v1.DeleteBlobRequest
 */
export const DeleteBlobRequest = new DeleteBlobRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParseDidRequest$Type extends MessageType<ParseDidRequest> {
    constructor() {
        super("highway.v1.ParseDidRequest", [
            { no: 1, name: "did", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<ParseDidRequest>): ParseDidRequest {
        const message = { did: "", metadata: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ParseDidRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ParseDidRequest): ParseDidRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string did */ 1:
                    message.did = reader.string();
                    break;
                case /* map<string, string> metadata */ 2:
                    this.binaryReadMap2(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: ParseDidRequest["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ParseDidRequest["metadata"] | undefined, val: ParseDidRequest["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field highway.v1.ParseDidRequest.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: ParseDidRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string did = 1; */
        if (message.did !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.did);
        /* map<string, string> metadata = 2; */
        for (let k of Object.keys(message.metadata))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message highway.v1.ParseDidRequest
 */
export const ParseDidRequest = new ParseDidRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResolveDidRequest$Type extends MessageType<ResolveDidRequest> {
    constructor() {
        super("highway.v1.ResolveDidRequest", [
            { no: 1, name: "did", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<ResolveDidRequest>): ResolveDidRequest {
        const message = { did: "", metadata: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResolveDidRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResolveDidRequest): ResolveDidRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string did */ 1:
                    message.did = reader.string();
                    break;
                case /* map<string, string> metadata */ 2:
                    this.binaryReadMap2(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: ResolveDidRequest["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ResolveDidRequest["metadata"] | undefined, val: ResolveDidRequest["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field highway.v1.ResolveDidRequest.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: ResolveDidRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string did = 1; */
        if (message.did !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.did);
        /* map<string, string> metadata = 2; */
        for (let k of Object.keys(message.metadata))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message highway.v1.ResolveDidRequest
 */
export const ResolveDidRequest = new ResolveDidRequest$Type();
